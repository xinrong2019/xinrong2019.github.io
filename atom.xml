<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://xinrong2019.github.io/</id>
    <title>Eucaly</title>
    <updated>2020-04-28T00:18:47.259Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://xinrong2019.github.io/"/>
    <link rel="self" href="https://xinrong2019.github.io/atom.xml"/>
    <subtitle>Time waits for no one.</subtitle>
    <logo>https://xinrong2019.github.io/images/avatar.png</logo>
    <icon>https://xinrong2019.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Eucaly</rights>
    <entry>
        <title type="html"><![CDATA[分布式基础理论认知]]></title>
        <id>https://xinrong2019.github.io/post/fen-bu-shi-ji-chu-li-lun-ren-zhi/</id>
        <link href="https://xinrong2019.github.io/post/fen-bu-shi-ji-chu-li-lun-ren-zhi/">
        </link>
        <updated>2020-04-28T00:15:50.000Z</updated>
        <content type="html"><![CDATA[<h1 id="分布式">分布式</h1>
<h2 id="toc">TOC</h2>
<p>[TOC]</p>
<h2 id="分布式系统定义及面临的问题">分布式系统定义及面临的问题</h2>
<p>分布式系统定义为：</p>
<blockquote>
<p>分布式系统是一个硬件或软件组件分布式在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p>
</blockquote>
<h3 id="分布式环境的各种问题">分布式环境的各种问题</h3>
<h4 id="通信异常">通信异常</h4>
<h4 id="网络分区">网络分区</h4>
<h4 id="三态">三态</h4>
<p>分布式系统每一个请求与响应存在特有的“三态”概念，即成功、失败和超时。</p>
<h4 id="节点故障">节点故障</h4>
<h2 id="分布式理论一致性概念">分布式理论：一致性概念</h2>
<p>不同场景对分布式一致性的需求是不同的。</p>
<p>火车站售票系统，要求数据是实时一致；</p>
<p>转账系统要求最终一致，但是要正确；</p>
<p>网购系统要求最终一致，中间会存在不一致的状态，但是最终也会是一致的。</p>
<h3 id="分布式一致性的提出">分布式一致性的提出</h3>
<p>数据库之间复制的延时。</p>
<p>为什么要数据复制：</p>
<ol>
<li>增加系统可用性，防止单点故障导致系统不可用</li>
<li>可以通过负载均衡，提高系统整体性能</li>
</ol>
<p>数据一致性，是指对一个副本数据进行更新的时候，必须确保也能更新其他的副本，否则不同副本之间的数据将不一致。</p>
<p>一致性级别：</p>
<ol>
<li>
<p>强一致性</p>
</li>
<li>
<p>弱一致性（尽可能保证一定时间内达到数据一致）</p>
</li>
<li>
<p>最终一致性（一定保证一定时间内达到数据一致）</p>
</li>
</ol>
<h3 id="分布式事务">分布式事务</h3>
<p>是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上，通常一个分布式事务会涉及到多个数据源或业务系统的操作。</p>
<h3 id="分布式理论-cap定理">分布式理论-CAP定理</h3>
<h4 id="什么是cap定理">什么是CAP定理</h4>
<p>CAP理论告诉我们，一个分布式系统，不可能同时满足一致性（C:Consistency），可用性（A:Availability）和分区容错性（P:Partition tolerance）这三个基本需求，最多只能同时满足其中两个。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419215151575.png" alt="image-20200419215151575" loading="lazy"></figure>
<p>对于分布式系统而言，分区容错性可以说是一个基本的要求，因此架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。</p>
<h4 id="能不能解决3选2的问题">能不能解决3选2的问题</h4>
<p>需要思考分区是不是百分之百出现呢？</p>
<p>如果不出现，那么就能够同时满足CAP。</p>
<p>如果出现了分区，可以根据策略进行调整。比如C不必使用那么强的一致性，可以先将数据存起来，稍后更新，实现所谓的“最终一致性”。</p>
<p>基于这个思路，也引出了第二个理论Base理论。</p>
<h3 id="分布式理论-base理论">分布式理论-BASE理论</h3>
<h4 id="什么是base理论">什么是BASE理论</h4>
<p>全称：Basically Available(基本可用)，Soft state(软状态)，和Eventually consistent(最终一致)三个短语的缩写，来自ebay的架构师提出。</p>
<h4 id="base理论和cap理论的关系">Base理论和CAP理论的关系</h4>
<p>Base理论是对CAP中一致性和可用性权衡的结果，其来源于大型互联网分布式实践的总结，是基于CAP定理逐步演化而来的。</p>
<h4 id="basically-available基本可用">Basically Available(基本可用)</h4>
<p>分布式系统在出现不可预知的故障时，允许损失部分可用性。而不是完全不可用。具体举两个例子：</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎要在0.5秒内返回用户相应结果，但由于出现故障，查询结果的响应时间增加到了1-2秒</li>
<li>功能上的损失：对于电商网站，在大促时，由于消费者的购物行为激增，为了保护系统的稳定性（或者保证一致性），部分消费者可能会被引导到一个降级页面。比如如下页面<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419220228459.png" alt="image-20200419220228459" style="zoom:50%;" /></li>
</ul>
<h4 id="soft-state软状态">Soft state(软状态)</h4>
<p>什么是软状态？相对于一致性，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p>
<p>软状态是指：允许系统中的数据存在中间状态，并认为该状态不影响系统整体可用性，即允许系统在多个不同节点的数据副本之间进行数据同步的过程中存在延迟。</p>
<h4 id="eventually-consistent最终一致">Eventually consistent(最终一致)</h4>
<p>强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>在实际工程实践中，最终一致性存在以下五类主要变种：</p>
<ol>
<li>
<p>因果一致性（Causal consistency）</p>
</li>
<li>
<p>读己之所写（Read your writes）</p>
</li>
<li>
<p>会话一致性（Session consistency）</p>
</li>
<li>
<p>单调读一致性（Monotonic read consistency）</p>
</li>
<li>
<p>单调写一致性（Monotonic write consistency）</p>
</li>
</ol>
<p>实际系统实践中，可以将其中若干个变种互相结合起来，以构建一个具有最终一致性的分布式系统。</p>
<p>总结：BASE理论面向的是大型高可用可扩展的分布式系统，通过牺牲强一致性来获得可用性，并允许数据在一段时间是不一致的，但最终要保证数据一致。</p>
<h3 id="分布式理论-一致性协议2pc">分布式理论-一致性协议2PC</h3>
<p>背景：为了使系统尽量能够达到CAP，于是有了BASE协议，而BASE协议是在可用性和一致性之间做的取舍和妥协。</p>
<p>我们在对分布式系统进行架构设计的时候，对可用性和一致性反复权衡的过程中，涌现了一些经典的算法和协议，最著名的几种就是二阶段提交协议，三阶段提交协议，Paxos算法等。</p>
<h4 id="什么是2pc">什么是2PC</h4>
<p>协调者：统一调度所有分布式节点的执行逻辑。负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。</p>
<p>参与者：被调度的节点</p>
<p>二阶段提交就是把事务的提交过程分成了两个阶段来进行处理。流程如下：</p>
<h5 id="阶段一提交事务请求">阶段一：提交事务请求</h5>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419222047888.png" alt="image-20200419222047888" style="zoom:33%;" />
<ol>
<li>事务询问</li>
</ol>
<p>协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
<ol start="2">
<li>执行事务</li>
</ol>
<p>各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中</p>
<p>（Redo用来保证事务的原子性和持久性，Undo能保证事务的一致性，两者也是系统恢复的基础前提）</p>
<ol start="3">
<li>各参与者向协调者反馈事务询问的响应</li>
</ol>
<p>如果参与者成功执行了事务操作，那么久反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务操作，就反悔No给协调者，表示事务不可以执行。</p>
<p>又称为投票阶段，即各参与者投票表明是否要继续执行接下来的事务提交操作。</p>
<h5 id="阶段二执行事务提交">阶段二：执行事务提交</h5>
<p>根据阶段一的结果决定是否可以进行事务提交操作，正常情况下，包含两种操作可能：提交事务，中断事务。</p>
<h6 id="提交事务过程如下">提交事务过程如下：</h6>
<p>假如阶段一所有参与者反馈都是Yes，那么就会执行事务的提交</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419222748654.png" alt="image-20200419222748654" style="zoom:33%;" />
<ol>
<li>发送提交请求</li>
</ol>
<p>协调者向所有参与者发送commit请求</p>
<ol start="2">
<li>事务提交</li>
</ol>
<p>参与者收到commit请求后，会正式执行事务提交操作，并在完成提价之后释放整个事务执行期间占用的事务资源。</p>
<ol start="3">
<li>反馈事务提交结果</li>
</ol>
<p>参与者在完成事务提交之后，向协调者发送Ack信息</p>
<ol start="4">
<li>完成事务</li>
</ol>
<p>协调者接收到所有参与者反馈的Ack信息后，完成事务。</p>
<h6 id="中断事务步骤如下">中断事务步骤如下：</h6>
<p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时后，协调者尚未接收到所有参与者的反馈响应，那么就会中断事务。</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419223154284.png" alt="image-20200419223154284" style="zoom:33%;" />
<ol>
<li>发送回滚请求</li>
</ol>
<p>协调者向所有参与者发送Rollback请求</p>
<ol start="2">
<li>事务回滚</li>
</ol>
<p>参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源</p>
<ol start="3">
<li>反馈事务回滚的结果</li>
</ol>
<p>参与者在完成事务回滚后，向协调者发送Ack信息</p>
<ol start="4">
<li>中断事务</li>
</ol>
<p>协调者接收到所有的参与者反馈的Ack信息后，完成事务中断。</p>
<p>2PC主要做了两个事情：投票，执行。</p>
<p>将事务的处理过程分为了投票和执行两个阶段，核心是对每个事务都采用先尝试后提交的处理方式，从而保证其原子性和一致性，因此可以将二阶段提交看成一个强一致性的算法。</p>
<h4 id="2pc优缺点">2PC优缺点</h4>
<p>优点：</p>
<p>原理简单，实现方便</p>
<p>缺点：</p>
<p>同步阻塞，单点问题，数据不一致，过于保守</p>
<ol>
<li>同步阻塞</li>
</ol>
<p>各个参与者在等待其他参与者响应的过程中，无法进行其他操作。限制了分布式系统的性能。然而分布式系统就是为了提高系统整体的性能。</p>
<ol start="2">
<li>单点问题</li>
</ol>
<p>协调者单点问题</p>
<ol start="3">
<li>数据不一致</li>
</ol>
<p>协调者向所有参与者发送commit请求后，发生了局部网络异常或者协调者在尚未发送完所有commit请求之前自身发生了崩溃，最终导致只有部分参与者收到了commit请求。将导致严重的数据不一致问题。</p>
<ol start="4">
<li>过于保守</li>
</ol>
<p>协调者通过超时机制判断是否需要中断事务，这种策略过于保守。</p>
<p>二阶段没有设计较为完善的容错机制，任意一个节点失败都会导致整个事务的失败。</p>
<h3 id="分布式理论-一致性协议3pc">分布式理论-一致性协议3PC</h3>
<p>背景：为了弥补阶段二提交的缺点</p>
<h4 id="什么是三阶段提交">什么是三阶段提交</h4>
<p>将2PC的提交事务请求过程一分为二，共形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419224754436.png" alt="image-20200419224754436" loading="lazy"></figure>
<h4 id="阶段一cancommit">阶段一：CanCommit</h4>
<ol>
<li>事务询问</li>
</ol>
<p>协调者向所有参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应</p>
<ol start="2">
<li>各参与者向协调者反馈事务询问的响应</li>
</ol>
<p>参与者在接收到来自协调者的包含了事务内容的canCommit请求后，正常情况下，如果自身认为可以顺利执行事务，则反馈Yes响应，并进入预备状态，否则反馈No响应</p>
<h4 id="阶段二precommit">阶段二：PreCommit</h4>
<p>协调者在得到所有参与者的响应之后，根据结果有两种执行操作的情况：执行事务预提交，或者中断事务</p>
<p>假如所有参与者反馈都是Yes，那么就会执行事务预提交</p>
<p>执行事务预提交分为三个步骤：</p>
<ol>
<li>发送预提交请求</li>
</ol>
<p>协调者向所有参与者节点发送preCommit请求，并进入prepared阶段。</p>
<ol start="2">
<li>事务预提交</li>
</ol>
<p>参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。</p>
<ol start="3">
<li>各参与者向协调者反馈事务执行的结果</li>
</ol>
<p>若参与者成功执行了事务操作，那么反馈Ack，同时等待最终的指令：提交或终止</p>
<p>若任一参与者反馈了No响应，或者在等待超时后，协调者尚未接收到所有参与者反馈，则中断事务</p>
<p>中断事务也分为两个阶段：</p>
<ol>
<li>
<p>发送中断请求</p>
</li>
<li>
<p>中断事务</p>
</li>
</ol>
<h4 id="阶段三docommit">阶段三：doCommit</h4>
<p>这个阶段，做真正的事务提交完成回滚</p>
<p>执行事务提交：</p>
<ol>
<li>发送提交请求</li>
<li>事务提交</li>
<li>反馈提交结果</li>
<li>完成事务</li>
</ol>
<p>中断事务：</p>
<ol>
<li>
<p>发送中断请求：协调者向所有参与者节点发送abort请求。</p>
</li>
<li>
<p>事务回滚</p>
</li>
<li>
<p>反馈事务回滚结果</p>
</li>
<li>
<p>中断事务</p>
</li>
</ol>
<p>一旦进入阶段三，可能会出现两种故障：</p>
<ol>
<li>协调者出现问题</li>
<li>协调者和参与者之间的网络故障</li>
</ol>
<p>如果出现任意一种情况，最终都会导致参与者无法收到doCommit请求或者abort请求，针对这种情况，<strong>参与者都会在等待超时之后，继续进行事务提交。</strong></p>
<h4 id="3pc优缺点">3PC优缺点</h4>
<p>优点</p>
<p>最大的优点是降低了参与者的阻塞范围（第一阶段不阻塞），其次能够在单点故障后继续达成一致（2PC在提交阶段会出现此问题，3PC会根据<strong>协调者的状态</strong>进行回滚或者提交）。</p>
<p>缺点</p>
<p>如果参与者收到了preCommit消息后，出现了网络分区，此时协调者所在节点和参与者所在节点无法进行网络通信，那么参与者等待超时后，会进行事务提交，这必然会出现分布式<strong>数据不一致</strong>的问题。</p>
<p>2PC和对比3PC</p>
<ol>
<li>
<p>对于协调者和参与者都设置了超时机制（而2PC只有协调者有超时机制，即如果在一定时间内，没有收到参与者的消息则默认失败）。</p>
</li>
<li>
<p>在2PC准备阶段和提交阶段之间，插入了预提交阶段，是一个缓冲，保证了最后提交阶段之前各个参与节点的状态是一致的。</p>
</li>
</ol>
<h3 id="分布式理论一致性算法paxos">分布式理论：一致性算法Paxos</h3>
<h4 id="什么是paxos算法">什么是Paxos算法</h4>
<p>一种基于消息传递且具有高度容错特性的一致性算法。主要用来解决分布式系统中，如何就某个值达成一致的算法。</p>
<p>Google Chubby</p>
<p>OceanBase</p>
<h4 id="paxos解决了什么问题">Paxos解决了什么问题</h4>
<p>解决了一致性问题</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419231712855.png" alt="image-20200419231712855" loading="lazy"></figure>
<p>在分布式系统中，发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序、网络分区）等情况。可以快速且准确的在集群内对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p>
<p>假如，一个集群环境中，要求所有机器上的状态是一致的，其中有两台机器想修改某一个状态，机器A想把状态修改为A，机器B想把状态修改为B，那么到底听谁的？</p>
<p>进一步思考，可以引入协调者，谁先到，听谁的。</p>
<p>但是协调者宕机了呢？</p>
<p>所以需要对协调者也做备份也要做集群，这时候，问题来了，这么多协调者，听谁的呢？</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419232217900.png" alt="image-20200419232217900" loading="lazy"></figure>
<p>Paxos算法就是为了解决这个问题而生的</p>
<h4 id="paxos相关概念">Paxos相关概念</h4>
<p>提案（Proposal）：最终要达成一致的value就在提案里。包括提案编号（Proposal ID）和提议的值（Value）</p>
<h5 id="三种角色">三种角色：</h5>
<ul>
<li>Proposer:提案发起者</li>
<li>Acceptor:决策者，可以批准提案，接受提案</li>
<li>Leaners:最终决策的学习者</li>
</ul>
<p>如果某个提案被选定，那么该提案的value就被选定了。</p>
<p>具体的实现中，一个进程可能同时充当多种角色。可能即是Proposer又是Acceptor又是Leaner。</p>
<h5 id="怎么理解对某个数据的值达成一致">怎么理解“对某个数据的值达成一致”？</h5>
<p>指的是Proposer、Acceptor、Leaner都认为同一个value被选定。</p>
<h5 id="那么proposer-acceptor-leaner分别在什么情况下才能认为某个value被选定呢">那么Proposer、Acceptor、Leaner分别在什么情况下才能认为某个value被选定呢？</h5>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419232931076.png" alt="image-20200419232931076" loading="lazy"></figure>
<h4 id="问题描述">问题描述</h4>
<p>假设有一组可以提出提案的进程集合，那么对于一个一致性算法需要保证以下几点：</p>
<ul>
<li>在这些被提出的提案中，只有一个提案会被选定</li>
<li>如果没有提案被提出，就不应该有被选定的提案</li>
<li>当一个提案被选定后，那么所有进程都应该能学习（learn）到这个被选定的value</li>
</ul>
<h4 id="推导过程">推导过程</h4>
<h5 id="最简单的方案只有一个acceptor">最简单的方案，只有一个Acceptor。</h5>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419233349101.png" alt="image-20200419233349101" loading="lazy"></figure>
<h5 id="多个acceptor">多个Acceptor</h5>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419233428220.png" alt="image-20200419233428220" loading="lazy"></figure>
<p>提出假设，从假设得到的约束提交</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419233552459.png" alt="image-20200419233552459" loading="lazy"></figure>
<p>上面是因为“一个提案只要被一个Acceptor接受，则该提案的value就被选定”才导致出现不一致的问题。因此，我们需要加一个规定：</p>
<blockquote>
<p>规定：一个提案被选定需要过半数以上的Acceptor接受</p>
</blockquote>
<p>上面的规定又暗示：一个Acceptor必须能够接受不止一个提案！</p>
<p>不然可能导致最终没有value被选定。</p>
<p>所以在这种情况下，我们使用一个<strong>全局的编号</strong>来标识每一个Acceptor批准的提案，当一个具有某value值的提案被半数以上Acceptor批准后，就认为该value被选定了，此时也认为该提案被选定了。</p>
<p>但是强调下，提案和value不是同一个概念，<code>提案=提案编号+value</code>。</p>
<p>根据上面的内容，我们现在虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值，否则又会出现不一致。</p>
<p>于是有了下面的约束：</p>
<blockquote>
<p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p>
</blockquote>
<p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p>
<blockquote>
<p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p>
</blockquote>
<p>只要满足了P2a，就能满足P2。</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419234707824.png" alt="image-20200419234707824" loading="lazy"></figure>
<p>上图会制造一个矛盾。虽然过半数Acceptor认为V1被选定，但是宕机恢复的Acceptor1接受了Proposer1提出的编号更新的提案的V2。</p>
<p>需要对P2a约束进行强化！</p>
<p>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所以我们可以对Proposer提出的提案进行约束。得到P2b：</p>
<blockquote>
<p>P2b：如果某个value为v的提案被选定，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p>
</blockquote>
<p>由P2b可以推出P2a进而推出P2。</p>
<p>那么如何达到P2b的约束呢？</p>
<p>主要满足P2C即可：</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419235458892.png" alt="image-20200419235458892" loading="lazy"></figure>
<h5 id="proposer生产提案">Proposer生产提案</h5>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001223255.png" alt="image-20200420001223255" loading="lazy"></figure>
<h5 id="acceptor接受提案">Acceptor接受提案</h5>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001245863.png" alt="image-20200420001245863" loading="lazy"></figure>
<blockquote>
<p>P1a：一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么他就可以接受这个编号为N的提案。</p>
</blockquote>
<h5 id="算法优化">算法优化</h5>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420000527733.png" alt="image-20200420000527733" loading="lazy"></figure>
<blockquote>
<p>如果Acceptor收到一个编号为N的Prepare请求，在此之前他已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。</p>
</blockquote>
<h4 id="paxos算法描述">Paxos算法描述</h4>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420000848207.png" alt="image-20200420000848207" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420000910502.png" alt="image-20200420000910502" loading="lazy"></figure>
<h4 id="leaner学习被选定的value">Leaner学习被选定的value</h4>
<p>上面介绍了如何来选定一个提案，下面看看如何让Leaner获取提案，大体有三种方案</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001022065.png" alt="image-20200420001022065" loading="lazy"></figure>
<h4 id="如何保证paxos算法的活性">如何保证Paxos算法的活性</h4>
<p>活性：最终一定会发生的事情：最终一定要选定value</p>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001348380.png" alt="image-20200420001348380" loading="lazy"></figure>
<p>总结：</p>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001658059.png" alt="image-20200420001658059" loading="lazy"></figure>
<h3 id="分布式理论一致性算法raft">分布式理论：一致性算法Raft</h3>
<h4 id="什么是raft算法">什么是Raft算法</h4>
<p><strong>Raft是一种为了管理复制日志的一致性算法</strong>。</p>
<p>Raft将一致性算法分解成几个关键模块，领导人选举、日志复制和安全性</p>
<p>通过实施一个更强的一致性来减少需要考虑的状态的数量。</p>
<p>Raft算法分为<strong>两个阶段，首先是选举过程，然后在选举出来的领导人带领下进行正常操作</strong>，比如日志复制。</p>
<h4 id="领导人选举">领导人选举</h4>
<p>Raft通过选举一个领导人，然后给予他全部的管理复制日志的责任来实现一致性。</p>
<p>在Raft中，任何时候一个服务器都可以扮演下面的角色之一：</p>
<ul>
<li>领导者：处理客户端交互，日志复制等操作，一般一次只有一个领导者</li>
<li>候选者：候选者就是选举过程中提名自己的实体，一旦选举成功，则成为领导者</li>
<li>跟随者：类似选民，完全被动的角色，这样的服务器等待被通知投票</li>
</ul>
<p>而影响他们身份变化的则是<strong>选举</strong>。</p>
<p>Raft使用心跳机制来触发选举。</p>
<p>当server启动时，初始状态都是follower。每一个server都有一个定时器，超时时间为election timeout(一般为150-300ms)，如果某server没有超时的情况下收到来自领导者或者候选者的任何消息，定时器重启；如果超时，它就开始一次选举。</p>
<p>下面用图示展示这个过程：</p>
<ol>
<li>任何一个服务器都可以成为候选者，它向其他服务器（选民）发出选举自己的请求，如图</li>
</ol>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420122557641_2020_04_20_12_25_57.png" alt="image-20200420122557641" loading="lazy"></figure>
<ol start="2">
<li>其他服务器同意了，回复OK指令，如图所示。</li>
</ol>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420122637006_2020_04_20_12_26_37.png" alt="image-20200420122637006" loading="lazy"></figure>
<p>此时如果有一个Follower服务器宕机，没有收到请求选举的要求，则只要达到半数以上的票数，候选人还是可以成为领导者。</p>
<ol start="3">
<li>这样，这个候选者就成为领导者，它可以向选民发出要执行具体操作的指令，比如进行日志复制。</li>
</ol>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420122810137_2020_04_20_12_28_10.png" alt="image-20200420122810137" loading="lazy"></figure>
<p>而如果领导者宕机，会引发新的选举，所以，整个集群在选举和正常运行两个状态之间切换，具体如下图：</p>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420122934631_2020_04_20_12_29_34.png" alt="image-20200420122934631" loading="lazy"></figure>
<p>从上图可以看出，选举和正常运行之间切换，但请注意，上图中的term3有一个地方，后面没有跟着正常阶段，为什么呢？</p>
<p>答：当一次选举失败（比如正巧每个人都透了自己），就执行一次加时赛，每个server会在一个随机的时间重新投票，这样就能保证不冲突了。所以，当term3选举失败，等了几十毫秒，执行term4选举，并成功选举出领导人。</p>
<p>接着，领导者周期性的向所有跟随者发送心跳包来维持自己的权威。</p>
<p>如果一个跟随者在一段时间内没有收到任何信息，也就是<strong>超时</strong>，那么他就会认为系统中没有可用的领导者，并且发起选举，以选出新的领导者。</p>
<p>要开始一次选举过程，跟随者要增加自己的当期任期号并转换到候选人状态。然后请求其他服务器为自己投票。那么会产生3种结果：</p>
<ol>
<li>自己成功当选</li>
<li>其他服务器成为领导者</li>
<li>僵住，没有任何一个人成为领导者</li>
</ol>
<p>注意：</p>
<ol>
<li>每一个server最多在一个任期内投出一张选票（有任期号约束），先到先得。</li>
<li>要求最多只能有一个人赢的选票。</li>
<li>一旦成功，立即成为领导人，然后广播所有服务器停止投票阻止新的领导者产生。</li>
</ol>
<p>僵住怎么办？raft通过使用随机选举超时时间方法将服务器打散投票。每个候选人在僵住的时候会随机从一个时间开始重新选举。</p>
<p>以上，就是Raft所有关于领导选举的策略。</p>
<h4 id="日志复制保证数据一致性">日志复制（保证数据一致性）</h4>
<p>Leader选出后，就开始接收客户端请求。Leader把请求作为日志条目加入到它的日志中，然后并行的向其他服务器发起AppendEntries RPC复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。</p>
<p>下图表示了当一个客户端发送一个请求给领导者，随后领导者复制给跟随者的整个过程。</p>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420131317613_2020_04_20_13_13_17.png" alt="image-20200420131317613" loading="lazy"></figure>
<p>4个步骤：</p>
<ul>
<li>客户端的每一个请求都包含被复制状态机执行的指令</li>
<li>leader把这个指令作为一条新的日志添加到日志中，然后并行发起RPC给其他服务器，让他们复制这条信息</li>
<li>跟随者响应ACK，如果follower宕机或者运行缓慢或者丢包，leader会不断重试，直到所有的follower最终都复制了所有的日志条目。</li>
<li>通知所有Follower提交日志，同时领导人提交这条日志到自己的状态机中，并返回给客户端。</li>
</ul>
<p>可以看到，直到第四步骤，整个事务才会达成。中间任何一个步骤发生故障，都不会影响日志的一致性。</p>
<h2 id="分布式系统设计策略">分布式系统设计策略</h2>
<p>分布式系统本质是通过将低廉的硬件攒在一起以获得更好的吞吐量、性能以及可用性等。</p>
<p>在分布式环境下，有几个问题是普遍关心的，我们称之为设计策略：</p>
<ul>
<li>如何检测当前节点还活着？</li>
<li>如何保障高可用</li>
<li>容错处理</li>
<li>负载均衡</li>
</ul>
<h3 id="心跳检测">心跳检测</h3>
<p>心跳，就是以固定的频率向其他节点汇报当前节点状态的方式。收到心跳，一般可以认为一个节点和现在的网络拓扑是良好的。当然，心跳汇报时，一般也会携带一些附加的状态、元数据信息，以便管理。</p>
<p>心跳不是万能的，收到心跳可以确认节点正常，但是收不到心跳也不能认为该节点就已经宣告&quot;死亡&quot;。此时，可以通过一些方法帮助Server做决定：周期检测心跳机制、累计失效检测机制。</p>
<p>周期检测心跳机制</p>
<p>Server端每间隔t秒向Node集群发起监测请求，设定超时时间，如果超过超过时间，则判断“死亡”。</p>
<p>累计失效检测机制</p>
<p>在周期监测心跳机制基础上，统计一定周期内节点的返回情况（包括超时及正确返回），以计算节点的死亡概率。另外，对于宣告“濒临死亡”的节点可以发起有限次数的重试，以作进一步判断。</p>
<h3 id="高可用设计">高可用设计</h3>
<p>经过设计来减少系统不能提供服务的时间。</p>
<p>系统高可用性常用设计模式包括三种：主备（Master-Slave）、互备（Active-Active）和集群（Cluster）模式。</p>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420182325069_2020_04_20_18_23_25.png" alt="image-20200420182325069" loading="lazy"></figure>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420182552945_2020_04_20_18_25_53.png" alt="image-20200420182552945" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420182714765_2020_04_20_18_27_15.png" alt="image-20200420182714765" loading="lazy"></figure>
<h3 id="容错性">容错性</h3>
<p>容错的处理是保障分布式环境下相应系统的高可用或者健壮性，一个典型的案例就是对于缓存穿透问题的解决方案。</p>
<p>具体看个例子，如图所示：</p>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420182850598_2020_04_20_18_28_50.png" alt="image-20200420182850598" loading="lazy"></figure>
<p>如果我们查询的某一数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，或者有人恶意攻击，如频繁发起id为-1的条件进行查询，可能DB就挂了。</p>
<p>那这种问题有什么好的解决办法吗？</p>
<p>一种方法可以缓存不存在的值，比如，key=&quot;null&quot;。</p>
<h3 id="负载均衡">负载均衡</h3>
<p>关键在于使用多台集群服务器共同分担计算任务，把网络请求及计算分配到集群可用的不同服务器节点上，从而达到高可用性及较好的用户操作体验。</p>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420183322517_2020_04_20_18_33_22.png" alt="image-20200420183322517" loading="lazy"></figure>
<h2 id="分布式架构网络通信">分布式架构网络通信</h2>
<p>Java领域通信的技术，有RMI、ESB、Hession、SOAP和JMS等，它们背后到底是基于什么原理实现的呢？</p>
<h3 id="基本原理">基本原理</h3>
<p>网络通信就是将流从一台计算机传输到另一台计算机，基于传输协议和网络IO来实现。</p>
<p>传输协议：TCP、UDP</p>
<p>网络IO：bio、nio、aio</p>
<h3 id="什么是rpc">什么是RPC</h3>
<p>RPC全称为remote procedure call，即远程过程调用。</p>
<p>借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式。</p>
<p>RPC本身不是具体的技术，是整个网络远程调用过程。</p>
<h4 id="rpc架构">RPC架构</h4>
<p>核心组件</p>
<ul>
<li>客户端（Client），服务的调用方</li>
<li>客户端存根（Client Stub），存放服务端端地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li>
<li>服务端（Server），真正的服务提供者。</li>
<li>服务端存根（Server Stub），接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li>
</ul>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420224748087.png" alt="image-20200420224748087" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225107848.png" alt="image-20200420225107848" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225147534.png" alt="image-20200420225147534" loading="lazy"></figure>
<p>对于RPC框架而言，核心模块就是通讯和序列化。</p>
<h3 id="rmi">RMI</h3>
<p>Remote Method Invocation，是Java原生支持的远程调用，才用JRMP作为通信协议。主要用于不同虚拟机间的通信。可以理解为一个虚拟机上的对象，调用另一个虚拟机上的对象。</p>
<h4 id="核心概念">核心概念</h4>
<figure data-type="image" tabindex="32"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225438139.png" alt="###" loading="lazy"></figure>
<p>以一个案例来讲解RMI的使用</p>
<h4 id="案例步骤">案例步骤</h4>
<figure data-type="image" tabindex="33"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225539956.png" alt="image-20200420225539956" loading="lazy"></figure>
<h4 id="代码实现">代码实现</h4>
<figure data-type="image" tabindex="34"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225616739.png" alt="image-20200420225616739" loading="lazy"></figure>
<p>其中有一个引用对象作为参数</p>
<figure data-type="image" tabindex="35"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225657770.png" alt="image-20200420225657770" loading="lazy"></figure>
<figure data-type="image" tabindex="36"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225718220.png" alt="image-20200420225718220" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225728445.png" alt="image-20200420225728445" loading="lazy"></figure>
<figure data-type="image" tabindex="38"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420231948021.png" alt="image-20200420231948021" loading="lazy"></figure>
<figure data-type="image" tabindex="39"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420231958643.png" alt="image-20200420231958643" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420232049926.png" alt="image-20200420232049926" loading="lazy"></figure>
<p>服务端</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420232156745.png" alt="image-20200420232156745" style="zoom:33%;" />
<p>客户端</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420232210761.png" alt="image-20200420232210761" style="zoom:33%;" />
<h4 id="实现原理">实现原理</h4>
<figure data-type="image" tabindex="41"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420232255853.png" alt="image-20200420232255853" loading="lazy"></figure>
<h3 id="bio-nio-aio">BIO、NIO、AIO</h3>
<p>以内存为目标，数据进内存叫IN，出内存叫OUT</p>
<h4 id="同步和异步">同步和异步</h4>
<p>不能光从字母意思了解，要从分布式的角度思考。</p>
<p>同步异步关注的是消息通信机制。</p>
<p>同步：</p>
<figure data-type="image" tabindex="42"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420235035589.png" alt="image-20200420235035589" loading="lazy"></figure>
<p>异步：</p>
<figure data-type="image" tabindex="43"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420235115587.png" alt="image-20200420235115587" loading="lazy"></figure>
<h4 id="阻塞和非阻塞">阻塞和非阻塞</h4>
<figure data-type="image" tabindex="44"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420235140376.png" alt="image-20200420235140376" loading="lazy"></figure>
<h4 id="bio">BIO</h4>
<h4 id="nio">NIO</h4>
<h4 id="aio">AIO</h4>
<h4 id="netty">Netty</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Zookeeper深度实践]]></title>
        <id>https://xinrong2019.github.io/post/zookeeper-shen-du-shi-jian/</id>
        <link href="https://xinrong2019.github.io/post/zookeeper-shen-du-shi-jian/">
        </link>
        <updated>2020-04-28T00:11:55.000Z</updated>
        <content type="html"><![CDATA[<h1 id="zookeeper">Zookeeper</h1>
<h2 id="toc">TOC</h2>
<p>[TOC]</p>
<p>分布式系统之间如何协作，信息同步和共享。</p>
<ul>
<li>通过网络进行信息共享</li>
<li>通过共享存储</li>
</ul>
<p>Zookeeper通过对节点的更新订阅，通知，达到信息共享。</p>
<h2 id="zookeeper的基本概念">Zookeeper的基本概念</h2>
<p>开源的分布式协调服务。可以基于它实现数据订阅发布、负载均衡、命名服务、集群管理、分布式锁和分布式队列等功能。</p>
<h3 id="基本概念">基本概念</h3>
<h4 id="集群角色">集群角色</h4>
<p>Leader：选举产生，Leader为客户端提供读写服务</p>
<p>Follower：提供读服务</p>
<p>Observer：提供读服务，不参与Leader选举，不参与写操作过半写成功策略，可以在不影响写性能等情况下提升集群的性能</p>
<h4 id="会话session">会话（session）</h4>
<p>客户端会话，一个客户端连接是指客户端和服务端之间的一个TCP长连接</p>
<p>Zookeeper对外的服务端口默认为2181</p>
<p>客户端启动的时候，首先会与服务器建立一个TCP长连接，从第一次连接建立开始，客户</p>
<p>端的生命周期也开始了，通过这个连接，客户端能够心跳检测与服务端保持有效的会话，</p>
<p>也能够向Zookeeper服务器发送请求并接受响应，</p>
<p>同时还能通过该连接接受来自服务器的Watch事件通知。</p>
<h4 id="数据节点znode">数据节点（Znode）</h4>
<p>节点的两种含义：机器节点，数据单元。</p>
<p>Zookeeper将所有数据存储在内存中，数据模型是一棵树，由斜杠（/）进行分割的路径，就是一个Znode，例如/app/path1。每个ZNode上都会保存自己的数据内容，同时还会保存一系列属性信息。</p>
<h4 id="版本">版本</h4>
<p>对于每个ZNode，Zookeeper都会为期维护一个叫作Stat的数据结构，Stat记录了这个ZNode的三个版本，分别是</p>
<ul>
<li>version(当前ZNode版本)</li>
<li>cversion(当前ZNode子节点的版本)</li>
<li>aversion(当前ZNode的ACL版本)</li>
</ul>
<h4 id="watcher事件监听器">Watcher（事件监听器）</h4>
<p>Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，Zookeeper服务端会将事件通知到感兴趣的客户端，该机制是Zookeeper实现分布式协调服务的重要特性。</p>
<h4 id="acl">ACL</h4>
<p>Access Control Lists，权限控制，其定义了五种权限：</p>
<ul>
<li>CREATE，创建自节点的权限</li>
<li>READ，获取节点数据和子节点列表的权限</li>
<li>WRITE，更新节点数据的权限</li>
<li>DELETE，删除子节点的权限</li>
<li>ADMIN，设置节点ACL的权限</li>
</ul>
<p>其中需要注意的是，CREATE和DELETE这两种权限都是针对子节点的权限控制</p>
<h2 id="zookeeper环境等搭建">Zookeeper环境等搭建</h2>
<h3 id="搭建方式">搭建方式</h3>
<h4 id="单机模式">单机模式</h4>
<ol>
<li>下载</li>
<li>解压 <code>tar -xzvf zookeeper-3.6.0.tar.gz</code></li>
<li>进入目录，创建data文件夹</li>
</ol>
<pre><code class="language-shell">cd zookeeper-3.6.0
mkdir data
</code></pre>
<ol start="4">
<li>修改配置文件</li>
</ol>
<p><code>dataDir='你的zookeeper存放目录'/data</code></p>
<ol start="5">
<li>启动Zookeeper服务</li>
</ol>
<p>进入bin目录，启动服务输入命令</p>
<p><code>./zkServer.sh start</code></p>
<ol start="6">
<li>关闭服务命令</li>
</ol>
<p><code>./zkServer.sh stop</code></p>
<ol start="7">
<li>查看状态</li>
</ol>
<p><code>./zkServer.sh status</code></p>
<h4 id="伪集群模式">伪集群模式</h4>
<p>注意事项：</p>
<p>clientPort不同，</p>
<p>dataDir不同，</p>
<p>dataLogDir不同，</p>
<p>还要在dataDir所对应的目录中创建myid文件来指定对应Zookeeper服务器的实例</p>
<p>server.X这个数字就是对应，data/myid中的数字。在3个server的myid文件中分别写入了1,2,3那么每个server中的zoo.cfg都配了server.1 server.2 server.3就行了。因为在同一台机器上，后面连着的2个端口，3个server都不要一样，否则会端口冲突。</p>
<ol>
<li>下载</li>
<li>解压，创建zkcluster目录</li>
</ol>
<p><code>mkdir zkcluster</code></p>
<ol start="3">
<li>改变名称</li>
</ol>
<p><code>mv zookeeper-3.6.0 zookeeper01</code></p>
<ol start="4">
<li>复制并改名</li>
</ol>
<pre><code class="language-shell">cp -r zookeeper01/ zookeeper02
cp -r zookeeper01/ zookeeper03
</code></pre>
<ol start="5">
<li>分别在三个zookeeper根目录下创建data和logs目录</li>
</ol>
<pre><code class="language-shell">mkdir data
cd data
mkdir logs
</code></pre>
<ol start="7">
<li>修改配置文件名称</li>
</ol>
<pre><code class="language-shell">cd conf
mv zoo.sample.cfg zoo.cfg
</code></pre>
<ol start="8">
<li>配置每一个ZK的dataDir（zoo.cfg）clientPort分别为2181,2182,2183</li>
</ol>
<pre><code class="language-shell">clientPort=2181
dataDir=/zkcluster/zookeeper01/data
dataLogDir=/zkcluster/zookeeper01/data/logs
</code></pre>
<pre><code class="language-shell">clientPort=2182
dataDir=/zkcluster/zookeeper02/data
dataLogDir=/zkcluster/zookeeper02/data/logs
</code></pre>
<pre><code class="language-shell">clientPort=2183
dataDir=/zkcluster/zookeeper03/data
dataLogDir=/zkcluster/zookeeper03/data/logs
</code></pre>
<ol start="9">
<li>配置集群</li>
</ol>
<p>在每个zookeeper的data目录下创建一个myid文件，内容分别是1,2,3。这个文件就是记录每个服务器的ID。</p>
<p><code>touch myid</code></p>
<p>在每个zookeeper的zoo.cfg文件中配置客户端访问端口和集群服务器IP列表</p>
<pre><code class="language-shell">server.1=192.168.101.25:2181:3881
server.2=192.168.101.25:2182:3882
server.3=192.168.101.25:2183:3882
#server.服务器ID=服务器IP地址:服务器之间通信端口:服务器之间投票选举端口
</code></pre>
<ol start="10">
<li>启动集群</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200428073640324.png" alt="image-20200428073640324" loading="lazy"></figure>
<h2 id="zookeeper的基本使用">Zookeeper的基本使用</h2>
<h3 id="zookeeper系统模型">Zookeeper系统模型</h3>
<h4 id="zookeeper数据模型znode">Zookeeper数据模型ZNode</h4>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200428075537809.png" alt="image-20200428075537809" loading="lazy"></figure>
<h4 id="znode的类型">ZNode的类型</h4>
<ul>
<li>持久性节点（Persistent）</li>
<li>临时性节点（Ephemeral）</li>
<li>顺序性节点（Sequential）</li>
</ul>
<p>在开发中，创建节点的时候通过组合可以生成以下四种节点类型：持久节点、持久顺序节点、临时节点、临时顺序节点。</p>
<p><strong>持久节点</strong>：节点被创建后，会一直存在服务器，直到服务器操作主动删除</p>
<p><strong>持久顺序节点</strong>：持久性和上面一样，顺序特性，就是节点在创建的时候，在节点名后面添加一个数字后缀，来表示其顺序。</p>
<p><strong>临时节点</strong>：会被自动清理的节点，客户端会话结束，节点就会被删除。临时节点不能创建子节点。</p>
<p><strong>临时顺序节点</strong>：有顺序的临时节点</p>
<h4 id="事务id">事务ID</h4>
<h4 id="znode的状态信息">ZNode的状态信息</h4>
<h4 id="watcher-数据变更通知">Watcher--数据变更通知</h4>
<h4 id="acl-保障数据安全">ACL--保障数据安全</h4>
<h3 id="zookeeper命令行操作">Zookeeper命令行操作</h3>
<h4 id="创建节点">创建节点</h4>
<h4 id="读取节点">读取节点</h4>
<h4 id="更新节点">更新节点</h4>
<h4 id="删除节点">删除节点</h4>
<h3 id="zookeeper的api使用">Zookeeper的api使用</h3>
<h4 id="建立会话">建立会话</h4>
<h4 id="创建节点-2">创建节点</h4>
<h4 id="获取节点数据">获取节点数据</h4>
<h4 id="修改节点数据">修改节点数据</h4>
<h4 id="删除节点-2">删除节点</h4>
<h3 id="zookeeper开源客户端">Zookeeper开源客户端</h3>
<h4 id="zkclient">ZKClient</h4>
<h4 id="curator">Curator</h4>
<h2 id="zookeeper应用场景">Zookeeper应用场景</h2>
<h3 id="数据发布订阅">数据发布/订阅</h3>
<h3 id="命名服务">命名服务</h3>
<h3 id="集群管理">集群管理</h3>
<h3 id="master选举">Master选举</h3>
<h3 id="分布式锁">分布式锁</h3>
<h4 id="排他锁">排他锁</h4>
<h4 id="共享锁">共享锁</h4>
<h4 id="羊群效应">羊群效应</h4>
<h3 id="分布式队列">分布式队列</h3>
<h2 id="zookeeper深入进阶">Zookeeper深入进阶</h2>
<h3 id="zab协议">ZAB协议</h3>
<h3 id="服务器角色">服务器角色</h3>
<h3 id="服务器启动">服务器启动</h3>
<h3 id="leader选举">Leader选举</h3>
<h2 id="zookeeper源码分析">Zookeeper源码分析</h2>
<h3 id="源码环境搭建">源码环境搭建</h3>
<h3 id="单机模式服务端启动">单机模式服务端启动</h3>
<h3 id="leader选举-2">Leader选举</h3>
<h3 id="fastleaderelection">FastLeaderElection</h3>
<h3 id="集群模式服务端">集群模式服务端</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础知识]]></title>
        <id>https://xinrong2019.github.io/post/java-ji-chu-zhi-shi/</id>
        <link href="https://xinrong2019.github.io/post/java-ji-chu-zhi-shi/">
        </link>
        <updated>2020-04-04T06:50:12.000Z</updated>
        <content type="html"><![CDATA[<h2 id="目标">目标</h2>
<p>以面试为导向，知识点要全面，查漏补缺。突出重点。</p>
<p>学完后有一个基本的认知是什么，对于重点内容要知道为什么，了解实现原理。</p>
<h2 id="基础">基础</h2>
<h3 id="强引用-弱引用-虚引用-软引用">强引用、弱引用、虚引用、软引用</h3>
<p>参见<a href="https://juejin.im/post/5a5129f5f265da3e317dfc08">Java中的四种引用类型</a></p>
<h4 id="背景">背景</h4>
<p>简单了解即可。和引用关联的知识点，不得不提对象的生命周期，再远点就是GC如何管理对象的生命周期的。这里假设读者已经知道这些内容了。</p>
<h4 id="引用强度认知">引用强度认知：</h4>
<p>引用强度从强到弱分别为：强引用、软引用、弱引用、虚引用。</p>
<h4 id="强引用-strongreference">强引用 StrongReference</h4>
<p>默认引用形式，使用时不需要显示定义。任何通过强引用所使用的对象不管系统资源有多紧张，Java GC都不会主动回收具有强引用的对象。</p>
<h4 id="弱引用-weakreference">弱引用 WeakReference</h4>
<p>如果一个对象只具有弱引用，无论内存充足与否，Java GC后对象如果只有弱引用将会被自动回收。</p>
<h4 id="软引用-softreference">软引用 SoftReference</h4>
<p>软引用和弱引用的特性基本一致， 主要的区别在于软引用在内存不足时才会被回收。如果一个对象只具有软引用，Java GC在内存充足的时候不会回收它，内存不足时才会被回收。</p>
<h4 id="虚引用-phantomreference">虚引用 PhantomReference</h4>
<p>从PhantomReference类的源代码可以知道，它的get()方法无论何时返回的都只会是null。所以单独使用虚引用时，没有什么意义，需要<strong>和引用队列ReferenceQueue类联合使用</strong>。当执行Java GC时如果一个对象只有虚引用，就会把这个对象加入到与之关联的ReferenceQueue中。</p>
<blockquote>
<p>文字干巴巴，去看原文代码</p>
</blockquote>
<h4 id="小结">小结</h4>
<p>强引用是 Java 的默认引用形式，使用时不需要显示定义，是我们平时最常使用到的引用方式。不管系统资源有多紧张，Java GC都不会主动回收具有强引用的对象。<br>
  弱引用和软引用一般在引用对象为非必需对象的时候使用。它们的区别是被弱引用关联的对象在垃圾回收时总是会被回收，被软引用关联的对象只有在内存不足时才会被回收。<br>
  虚引用的get()方法获取的永远是null，无法获取对象实例。Java GC会把虚引用的对象放到引用队列里面。可用来在对象被回收时做额外的一些资源清理或事物回滚等处理。<br>
  由于无法从虚引获取到引用对象的实例。它的使用情况比较特别，所以这里不把虚引用放入表格进行对比。这里对强引用、弱引用、软引用进行对比：</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200403134544324_2020_04_03_13_47_09.png" alt="" loading="lazy"></figure>
<h3 id="final关键字的作用-方法-变量-类">final关键字的作用 (方法、变量、类)</h3>
<p>参见<a href="https://www.jianshu.com/p/e43c3273d7d5">final 关键字</a></p>
<p>应用在方法、变量、类上的作用不赘述，已经掌握，只查漏补缺</p>
<ul>
<li>
<p>被final修饰的方法，不可以被重写。但是不影响本类的重载以及重载函数的重写。</p>
</li>
<li>
<p>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</p>
</li>
</ul>
<p>不可变的类是天然无状态的，线程安全的。</p>
<h4 id="如何写一个不可变类呢">如何写一个不可变类呢？</h4>
<ul>
<li>将类声明为final，所以它不能被继承</li>
<li>将所有的成员声明为私有的，这样就不允许直接访问这些成员</li>
<li>对变量不要提供setter方法</li>
<li>将所有可变的成员声明为final，这样只能对它们赋值一次</li>
<li>通过构造器初始化所有成员，进行深拷贝(deep copy)</li>
<li>在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝</li>
</ul>
<p>具体可参考String和Integer等的写法</p>
<h4 id="和static一起使用">和static一起使用</h4>
<p>对于静态final变量，我们可以直接初始化，或者使用静态代码块。而不可以使用构造函数或者构造代码块。</p>
<p>因为static要求在编译期间就确定值，然后放入静态区。而构造函数和构造代码块发生在运行期间。</p>
<h4 id="final和private">final和private</h4>
<p>类中所有的private方法都隐式的指定为final的，由于无法取用private方法，所以也就无法覆盖它，可以对private方法添加final修饰符，但并没有添加任何额外意义。（了解即可）</p>
<h3 id="泛型-泛型继承-泛型擦除">泛型、泛型继承、泛型擦除</h3>
<p><a href="https://blog.csdn.net/u012706811/article/details/53464612">泛型擦除分析</a><br>
<a href="https://juejin.im/post/5e61fb10e51d4526d6406cb0#heading-4">泛型擦除是什么，会带来什么问题？</a></p>
<h4 id="泛型擦除">泛型擦除</h4>
<p>使用泛型的话,<strong>运行期把对象都是当成object来处理的</strong>,所以可以运用的方法都是object的方法,且在赋值操作时,编译器会自动强转为指定泛型类型,另一个好处就是在编译期更早的发现向下转型可能出现的错误,因为向下转型是不安全的.</p>
<h4 id="带来什么样的问题">带来什么样的问题？</h4>
<p>在运行时反编译添加不同类型的数据，数据错误，代码不报错。</p>
<h4 id="泛型继承带上界的擦除">泛型继承，带上界的擦除</h4>
<p>当使用上界时泛型擦除擦除为上界的类型,因此也就解释了为啥可以调用上界的方法.并且会和赋值操作的时候一样自动强转为对应的泛型,向上转型,为安全的操作。</p>
<h4 id="带通配符的上界">带通配符的上界</h4>
<h4 id="带通配符的下界">带通配符的下界</h4>
<h4 id="总结">总结</h4>
<p>泛型的出现是为了减少向下转型出现的错误,泛型的目的是<strong>尽可能的在编译器发现转型时的错误</strong>,所以对于不安全的操作(编译器认为的)会绝对禁止,存储进去的都是绝对安全(编译器认为的)的数据.</p>
<h3 id="jdk-serviceloader">jdk ServiceLoader</h3>
<p>参见<a href="https://juejin.im/post/5d2db85d6fb9a07ea7134408">Java SPI机制：ServiceLoader实现原理及应用剖析</a></p>
<p>SPI，全称<code>Service Provider Interfaces</code>，服务提供接口。可以用来<strong>解耦服务的实现和使用，增强应用的可扩展性</strong>。</p>
<p>JDK中，基于SPI的思想，提供了默认具体的实现，<code>ServiceLoader</code>。利用JDK自带的<code>ServiceLoader</code>，可以轻松实现面向<code>服务的注册与发现</code>，完成服务提供与使用的<code>解耦</code>。</p>
<h4 id="使用">使用</h4>
<p>外部使用时，往往通过<code>load(Class service, ClassLoader loader)</code>或<code>load(Class service)</code>调用，最后都是在<code>reload</code>方法中创建了<code>LazyIterator</code>对象，<code>LazyIterator</code>是<code>ServiceLoader</code>的内部类，实现了<code>Iterator</code>接口，其作用是一个懒加载的迭代器，在<code>hasNextService</code>方法中，完成了对位于<code>META-INF/services/</code>目录下的配置文件的解析，并在<code>nextService</code>方法中，完成了对具体实现类的实例化。</p>
<p><code>META-INF/services/</code>，是<code>ServiceLoader</code>中约定的接口与实现类的关系配置目录，文件名是接口全限定类名，内容是接口对应的具体实现类，如果有多个实现类，分别将不同的实现类都分别作为每一行去配置。解析过程中，通过<code>LinkedHashMap&lt;String,S&gt;</code>数据结构的<code>providers</code>，将已经发现了的接口实现类进行了缓存，并对外提供的<code>iterator()</code>方法，方便外部遍历。</p>
<h4 id="总结-2">总结</h4>
<p>基于服务提供与发现的思想，系统自带的<code>ServiceLoader</code>以及基于此思想基础上的演化形式，被广泛的使用到实际的项目中。本质上，<strong>通过服务接口约定、服务注册与服务发现，完成将服务提供方与服务使用方的解耦，大大扩展了系统的可扩展性</strong>。<strong>服务注册的本质，是将服务接口与具体服务实现的映射关系注册到系统或特定实现中。服务发现的过程，本质上是向系统或特定实现去匹配对应的具体实现类</strong>，但在写法上是基于接口的编程方式，因为服务使用方和服务提供方彼此都是透明与未感知的。基于<code>SPI</code>思想的<code>ServiceLoader</code>实现及演化，在项目的组件化，或实现扩展性功能，甚至完成具有可插拔能力的插件化模块时，往往都被广泛使用到。</p>
<h3 id="linkedlist-linkedhashmap-lru">LinkedList、LinkedHashMap、LRU</h3>
<h4 id="linkedlist">LinkedList</h4>
<p>底层数据结构</p>
<h3 id="设计模式">设计模式</h3>
<h4 id="装饰者模式">装饰者模式</h4>
<h4 id="代理模式">代理模式</h4>
<h4 id="责任链模式">责任链模式</h4>
<h4 id="工厂模式">工厂模式</h4>
<h4 id="适配器模式">适配器模式</h4>
<h4 id="建造者模式">建造者模式</h4>
<h4 id="单例模式">单例模式</h4>
<h4 id="模板模式">模板模式</h4>
<h4 id="观察者模式">观察者模式</h4>
<h3 id="关于精度损失问题int-long-超过最大值">关于精度损失问题：int、long 超过最大值</h3>
<h3 id="关于注解元注解的种类-继承javalangannotation-注解的基础类型-注解的常用方法">关于注解：元注解的种类、继承java.lang.Annotation、注解的基础类型、注解的常用方法</h3>
<h3 id="关于classloader类加载器双亲委派模型">关于ClassLoader，类加载器，双亲委派模型</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java基础知识清单]]></title>
        <id>https://xinrong2019.github.io/post/java-ji-chu/</id>
        <link href="https://xinrong2019.github.io/post/java-ji-chu/">
        </link>
        <updated>2020-04-04T06:42:46.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://class.imooc.com/lesson/1222#mid=29173"><strong>1-17 福利：Java基础面试考点清单</strong></a><br>
<strong>带着问题与技术关键词，有目标的开启体系化学习之旅~</strong></p>
<ul>
<li>
<p><strong>基础：</strong></p>
</li>
<li>
<ul>
<li>强引用、弱引用、虚引用、软引用</li>
<li>final关键字的作用 (方法、变量、类)</li>
<li>泛型、泛型继承、泛型擦除</li>
<li>jdk ServiceLoader</li>
<li>LinkedList、LinkedHashMap、LRU</li>
<li>装饰者模式、代理模式、责任链模式、工厂模式、适配器模式、建造者模式、单例模式、模板模式、观察者模式…</li>
<li>关于精度损失问题：int、long 超过最大值</li>
<li>关于注解：元注解的种类、继承java.lang.Annotation、注解的基础类型、注解的常用方法</li>
<li>关于ClassLoader，类加载器，双亲委派模型</li>
</ul>
</li>
<li>
<p><strong>J.U.C</strong></p>
</li>
<li>
<ul>
<li>线程池参数说明，线程池的线程回收、shutdown</li>
<li>线程池的生命周期？</li>
<li>线程池的核心模型Worker对象的运作流程是怎样的？</li>
<li>线程池的拒绝策略有哪4种？</li>
<li>线程池的提交，execute与submit有什么区别？在实际开发中需要注意哪些问题？</li>
<li>threadlocal原理，数据结构</li>
<li>并发集合类了解哪些？</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>ConcurrentHashMap</li>
<li>CopyOnWrite集合、原理、锁机制</li>
<li>ConcurrentLinkedQueue、LinkedTransferQueue、ArrayBlockingQueue、PriorityBlockingQueue、SynchronousQueue、DelayQueue</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>AQS 原理：</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>独占 &amp; 共享</li>
<li>state &amp; CHL队列</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>锁：</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>Synchronized、ReentrantLock、RWLock、Condition、LockSupport、StampedLock、</li>
<li>概念：CAS 自旋、重入、偏向</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>volatile：</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>多线程共享 &amp; 阻止指令重排序</li>
<li>jvm的逃逸分析 &amp; Tlab &amp; 消除伪共享 &amp; UNsafe &amp;</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>atomic:</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>CAS的缺点，自旋、ABA问题</li>
<li>atomic 原子性、Reference、referenceArray、longadder</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>并发控制：</li>
<li>barrier、countdownlatch、exchanger、future、semaphore</li>
</ul>
</li>
<li>
<p><strong>jvm虚拟机：</strong></p>
</li>
<li>
<ul>
<li>虚拟机内存模型</li>
<li>新生代（Eden S0 S1）、老年代 、MetaSpace （比例）</li>
<li>垃圾回收算法（引用计数、标记压缩、清除、复制算法、分区）、垃圾收集器</li>
<li>GC停顿、吞吐量，进入老年代阈值、大对象回收问题等</li>
<li>jvm性能调优、参数配置</li>
<li>常用命令：jstat、jmap、jstack等</li>
<li>内存溢出分析：堆内、堆外 （含义、如何设置）</li>
<li>CPU飙升：死锁、线程阻塞</li>
<li>关于GC: minor major full</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>stw，安全点等</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数据结构&amp;算法</strong></p>
</li>
<li>
<ul>
<li>数组、链表、树、队列…</li>
<li>关于时间复杂度，时间换空间转换案例</li>
<li>关于排序、冒泡、快排、递归、二分搜索、位运算</li>
</ul>
</li>
<li>
<p><strong>Spring</strong></p>
</li>
<li>
<ul>
<li>Spring生命周期，流程梳理</li>
<li>Spring扩展点作用</li>
<li>Spring IOC AOP 基本原理</li>
<li>动态代理</li>
<li>BeanPostProcessor 作用？</li>
<li>ApplicationContextAware 的作用和使用？</li>
<li>BeanNameAware与BeanFactoryAware的先后顺序？</li>
<li>InitializingBean 和 BeanPostProcessor 的after方法先后顺序？</li>
<li>ApplicationListener监控的Application事件有哪些？</li>
<li>Spring模块装配的概念，比如@EnableScheduling @EnableRetry @EnableAsync，@Import注解的作用？</li>
<li>ImportBeanDefinitionRegistrar 扩展点用于做什么事情？</li>
<li>ClassPathBeanDefinitionScanner 的作用？</li>
<li>NamespaceHandlerSupport 命名空间扩展点的作用？</li>
<li>如何实现动态注入一个Bean？</li>
<li>如何把自定义注解所在的Class 初始化注入到Spring容器？</li>
<li>BeanDefinition指的是什么，与BeanDefinitionHolder的区别，Spring如何存储BeanDefinition实例？</li>
<li>ASM 与 CGlib</li>
<li>Spring的条件装配，自动装配</li>
</ul>
</li>
<li>
<p><strong>RPC通信框架</strong></p>
</li>
<li>
<ul>
<li>Dubbo</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>Dubbo的Spi机制？</li>
<li>Dubbo的核心模型 invoker、invocation、filter</li>
<li>Dubbo的隐式传递?</li>
<li>Dubbo的泛化调用？</li>
<li>Dubbo的export与importer时机？</li>
<li>Dubbo的服务调用过程？</li>
<li>Dubbo的负载均衡策略？</li>
<li>Dubbo的集群容错？</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>网络通信</strong></p>
</li>
<li>
<ul>
<li>IO / NIO</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>IO NIO区别？</li>
<li>多路复用的概念，Selector</li>
<li>Channel的概念、Bytebuf的概念，flip、position…</li>
<li>FileChannel 如何使用？</li>
<li>RAF使用，seek、skip方法</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>Netty</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>关于Netty的Reactor实现？</li>
<li>Netty的ByteBuf有哪些？</li>
<li>内存与非内存Bytebuffer的区别与使用场景？</li>
<li>池化与非池化buffer的区别与使用场景？</li>
<li>关于Netty的请求Buffer和响应Buffer?</li>
<li>Netty的ChannelPipeline设计模式？</li>
<li>Netty的核心option参数配置？</li>
<li>Netty的ChannelInboundHandlerAdapter和SimpleChannelInboundHandler关系？</li>
<li>Netty的EventLoop核心实现？</li>
<li>Netty的连接管理事件接口有哪些常用方法（ChannelDuplexHandler）？</li>
<li>Netty的编解码与序列化手段</li>
<li>Netty的FastThreadLocal实现？</li>
<li>Netty中应用的装饰者 和 观察者模式在哪里体现？</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>MQ</strong></p>
</li>
<li>
<ul>
<li>API使用，常用生产消费模型，集群架构搭建</li>
<li>常见问题，消息可靠性投递、幂等性保障</li>
<li>概念、原理、存储、消息投递、通信机制、性能相关优化</li>
<li>MQ常见的作用于目的、服务解耦、削峰填谷等</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>RocketMQ</li>
<li>Kafka</li>
<li>RabbitMQ</li>
<li>ActiveMQ</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>缓存</strong></p>
</li>
<li>
<ul>
<li>内存缓存</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>堆外内存缓存 回收释放</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>Redis</li>
</ul>
</li>
<li>
<ul>
<li>
<ul>
<li>缓存穿透、雪崩、热点Key、大Key、无底洞问题，缓存更新与淘汰、缓存与数据库的一致性</li>
<li>Redis的幂等性</li>
<li>Redis的分布式锁实现</li>
<li>Redis的原子性，Redis的特点</li>
<li>Redis集群相关问题、一致性hash、slot概念等</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>流控组件</strong></p>
</li>
<li>
<ul>
<li>Hystrix</li>
<li>Sentinel</li>
</ul>
</li>
<li>
<p><strong>高可用服务中间件</strong></p>
</li>
<li>
<ul>
<li>Zookeeper / Curator</li>
<li>Nginx</li>
<li>Haproxy</li>
<li>LVS</li>
<li>Haproxy</li>
</ul>
</li>
<li>
<p><strong>数据库存储&amp;调度</strong></p>
</li>
<li>
<ul>
<li>Sharding-JDBC</li>
<li>ElasticJob</li>
<li>调度平台相关：DAG、airflow等</li>
</ul>
</li>
<li>
<p><strong>搜索相关度</strong></p>
</li>
<li>
<ul>
<li>ELK ，数据库加速、主搜（算法）</li>
</ul>
</li>
<li>
<p>Logback、Slf4j2</p>
</li>
<li>
<p>Solr &amp; Lucene</p>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SpringCloud Alibaba学习笔记]]></title>
        <id>https://xinrong2019.github.io/post/springcloud-alibaba-xue-xi-bi-ji/</id>
        <link href="https://xinrong2019.github.io/post/springcloud-alibaba-xue-xi-bi-ji/">
        </link>
        <updated>2020-04-04T06:41:43.000Z</updated>
        <content type="html"><![CDATA[<h1 id="springcloud-alibaba学习笔记">SpringCloud Alibaba学习笔记</h1>
<h2 id="目录">目录</h2>
<p>[TOC]</p>
<h2 id="导学">导学</h2>
<h3 id="为什么学">为什么学</h3>
<ul>
<li>组件性能更强</li>
<li>良好的可视化界面</li>
<li>搭建简单，学习曲线低</li>
<li>文档丰富并且是中文</li>
</ul>
<h3 id="学习目标">学习目标</h3>
<ul>
<li>Spring Cloud Alibaba核心组件的用法及实现原理</li>
<li>Spring Cloud Alibaba结合微信小程序从&quot;0&quot;学习真正开发中的使用</li>
<li>实际工作中如何避免踩坑，正确的思考问题方式</li>
<li>Spring Cloud Alibaba的进阶：代码的优化和改善，微服务监控</li>
</ul>
<h3 id="进阶目标">进阶目标</h3>
<ul>
<li>如何提升团队的代码质量
<ul>
<li>编码技巧</li>
<li>心得总结</li>
</ul>
</li>
<li>如何改善代码结构设计
<ul>
<li>借助监控工具</li>
<li>定位问题</li>
<li>解决问题</li>
</ul>
</li>
</ul>
<h3 id="思路">思路</h3>
<p>分析并拆解微服务-&gt;编写代码-&gt;分析现有架构问题-&gt;引入微服务组件-&gt;优化重构-&gt;总结完善</p>
<h3 id="spring-cloud-alibaba的重要组件">Spring Cloud Alibaba的重要组件</h3>
<ul>
<li>服务发现Nacos
<ul>
<li>服务发现原理剖析</li>
<li>Nacos Server/Client</li>
<li>高可用Nacos搭建</li>
</ul>
</li>
<li>实现负载均衡Ribbon
<ul>
<li>负载均衡的常见模式</li>
<li>RestTemplate整合Ribbon</li>
<li>Ribbon配置自定义</li>
<li>如何扩展Ribbon</li>
</ul>
</li>
<li>声明式HTTP客户端-Feign
<ul>
<li>如何使用Feign</li>
<li>Feign配置自定义</li>
<li>如何扩展Feign</li>
</ul>
</li>
<li>服务容错Sentinel
<ul>
<li>服务容错原理</li>
<li>Sentinel</li>
<li>Sentinel DashBoard</li>
<li>Sentinel核心原理分析</li>
</ul>
</li>
<li>消息驱动RocketMq
<ul>
<li>Spring Cloud Stream</li>
<li>实现异步消息推送与消费</li>
</ul>
</li>
<li>API网关Gateway
<ul>
<li>整合Gateway</li>
<li>三大核心</li>
<li>聚合微服务请求</li>
</ul>
</li>
<li>用户认证与授权
<ul>
<li>认证授权的常见方案</li>
<li>改造Gateway</li>
<li>扩展Feign</li>
</ul>
</li>
<li>配置管理Nacos
<ul>
<li>配置如何管理</li>
<li>配置动态刷新</li>
<li>配置管理的最佳实践</li>
</ul>
</li>
<li>调用链监控Sleuth
<ul>
<li>调用链监控原理剖析</li>
<li>Sleuth使用</li>
<li>Zipkin使用</li>
</ul>
</li>
</ul>
<h2 id="环境搭建">环境搭建</h2>
<ul>
<li>JDK8</li>
<li>MySQL</li>
<li>Maven的安装与配置</li>
<li>IDEA</li>
</ul>
<h2 id="spring-boot必知必会">Spring Boot必知必会</h2>
<h3 id="spring-boot特性">Spring Boot特性</h3>
<ul>
<li>无需部署WAR文件</li>
<li>提供stater简化配置</li>
<li>尽可能自动配置Spring以及第三方库</li>
<li>提供&quot;生产就绪&quot;功能，例如指标、健康检查、外部配置等</li>
<li>无代码生成&amp;无XML</li>
</ul>
<h3 id="编写第一个spring-boot应用">编写第一个Spring Boot应用</h3>
<h3 id="spring-boot应用组成分析">Spring Boot应用组成分析</h3>
<ul>
<li>依赖：pom.xml</li>
<li>启动类：注解</li>
<li>配置：application.properties</li>
<li>static目录：静态文件</li>
<li>templates目录：模板文件</li>
</ul>
<h3 id="spring-boot开发三板斧">Spring Boot开发三板斧</h3>
<ul>
<li>加依赖</li>
<li>写注解</li>
<li>写配置</li>
</ul>
<h3 id="spring-boot-actuator">Spring Boot Actuator</h3>
<p>监控工具</p>
<h4 id="actuator">/actuator</h4>
<p>入口</p>
<h4 id="health">/health</h4>
<p>健康检查</p>
<p>显示详情配置</p>
<pre><code class="language-properties">management.endpoint.health.show-details=always
# 显示所有监控端点
management.endpoints.web.exposure.include=*

# 描述信息（自定义键值对）
info.app-name=spring-boot-demo
info.author=kim
info.email=xxx@163.com
</code></pre>
<h3 id="spring-boot配置管理">Spring Boot配置管理</h3>
<p>支持的配置格式</p>
<pre><code class="language-yaml">management:
  endpoint:
    health:
      show-details: always
  endpoints:
    web:
      exposure:
        include: '*'

  # 描述信息
info:
  app-name: spring-boot-demo
  author: kim
  email: xxx@163.com
</code></pre>
<p>注意：值是*，yml写法需要加引号</p>
<ul>
<li>yml是使用趋势</li>
<li>yml在有的配置中可以表达顺序，properties不行</li>
</ul>
<p>17种配置方式</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/2ncu17_2020_04_04_12_37_13.png" alt="" loading="lazy"></figure>
<p>实际项目种经常用到的配置管理方式：</p>
<ul>
<li>配置文件</li>
<li>环境变量</li>
<li>外部配置文件</li>
<li>命令行参数</li>
</ul>
<h4 id="环境变量方式配置管理">环境变量方式配置管理</h4>
<p>application.yml</p>
<pre><code class="language-yaml">management:
  endpoint:
    health:
      show-details: ${SOME_ENV}
  endpoints:
    web:
      exposure:
        include: '*'

  # 描述信息
info:
  app-name: spring-boot-demo
  author: kim
  email: xxx@163.com
</code></pre>
<p>设置环境变量<code>SOME_ENV</code></p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/E5UBsc_2020_04_04_12_45_05.png" alt="" loading="lazy"></figure>
<h4 id="环境变量方式配置管理java-jar方式">环境变量方式配置管理（java -jar方式）</h4>
<p><code>mvn clean install -DskipTests</code></p>
<p><code>java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar --SOME_ENV=always</code></p>
<h4 id="外部配置文件方式配置管理">外部配置文件方式配置管理</h4>
<p>将打的jar包和配置文件放在同一目录，会优先读取该配置文件内配置</p>
<h4 id="命令行参数方式配置管理">命令行参数方式配置管理</h4>
<p><code>java -jar spring-boot-demo-0.0.1-SNAPSHOT.jar --server.port=8081</code></p>
<h4 id="最佳实践">最佳实践</h4>
<p>KISS，规避掉优先级，没人会记住17中配置姿势的优先级。</p>
<h3 id="profile">Profile</h3>
<pre><code class="language-yaml"># 所有环境下公用的配置属性
management:
  endpoint:
    health:
      show-details: ${SOME_ENV}
  endpoints:
    web:
      exposure:
        include: '*'

  # 描述信息
info:
  app-name: spring-boot-demo
  author: kim
  email: xxx@163.com

# 连字符
---
# profile=x的专用属性，也就是说某个环境下的专用属性
# 开发环境
spring:
  profiles: dev

---
# profile=y的专用属性，也就是说某个环境下的专用属性
# 生产环境
spring:
  profiles: prod
server:
  tomcat:
    max-threads: 300
    max-connections: 1000
</code></pre>
<p>IDEA启动配置</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/0cmidO_2020_04_04_13_00_38.png" alt="" loading="lazy"></figure>
<p>访问http://localhost:8080/actuator/configprops通过actuator端口查看</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/L6Qjuf_2020_04_04_13_03_39.png" alt="" loading="lazy"></figure>
<p>默认使用default，可以通过添加配置设置默认profile</p>
<pre><code class="language-yaml">spring:
  profiles:
    active: dev
</code></pre>
<h4 id="最佳实践-2">最佳实践</h4>
<p>KISS，不要使用优先级，规划好公用和专用配置</p>
<h2 id="微服务拆分与编写">微服务拆分与编写</h2>
<ul>
<li>单体架构vs微服务架构
<ul>
<li>单体架构是什么</li>
<li>微服务是什么</li>
<li>微服务特性</li>
<li>微服务全景架构图</li>
<li>微服务优缺点</li>
<li>微服务适用场景</li>
</ul>
</li>
<li>业务分析与建模
<ul>
<li>项目功能演示与分析</li>
<li>微服务拆分</li>
<li>项目架构图</li>
<li>数据库设计</li>
<li>API文档</li>
</ul>
</li>
<li>编写微服务
<ul>
<li>创建小程序</li>
<li>创建项目</li>
<li>编写用户微服务</li>
<li>编写内容微服务</li>
</ul>
</li>
</ul>
<h3 id="单体架构">单体架构</h3>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/euh6g8_2020_04_04_13_11_38.png" alt="" loading="lazy"></figure>
<p>优点：</p>
<ul>
<li>架构简单</li>
<li>开发、测试、部署方便</li>
</ul>
<p>缺点：</p>
<ul>
<li>复杂性高</li>
<li>部署慢，频率低</li>
<li>扩展能力受限（比如用户模块是CPU密集的，只能通过买更好的CPU的机器，比如内容模块是IO密集的，只能通过购买更多内存）</li>
<li>阻碍技术创新（SpringMVC-&gt;Spring Web Flux，改动大）</li>
</ul>
<p>不适合庞大复杂的系统</p>
<h3 id="微服务">微服务</h3>
<p>拆分后的小型服务</p>
<h4 id="微服务的特性">微服务的特性</h4>
<ul>
<li>每个微服务可独立运行在自己的进程里；（每个服务一个Tomcat）</li>
<li>一系列独立运行的微服务共同构建起整个系统</li>
<li>每个服务为独立的业务开发，一个微服务只关注某个特定的功能，例如订单管理、用户管理</li>
<li>可以使用不同的语言与数据存储技术（契合项目情况和团队实力）</li>
<li>微服务之间通过轻量的通信机制进行通信，例如通过Rest API进行调用；（通信协议轻量、跨平台）</li>
<li>全自动的部署机制</li>
</ul>
<h4 id="微服务全景架构图">微服务全景架构图</h4>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/9qjnWH_2020_04_04_13_24_06.png" alt="" loading="lazy"></figure>
<h4 id="优点">优点</h4>
<ul>
<li>单个服务更易于开发、维护</li>
<li>单个微服务启动较快</li>
<li>局部修改容易部署</li>
<li>技术栈不受限</li>
</ul>
<h4 id="缺点">缺点</h4>
<ul>
<li>运维要求高</li>
<li>分布式固有的复杂性</li>
<li>重复劳动（不同语言调用相同功能时）</li>
</ul>
<h4 id="适用场景">适用场景</h4>
<ul>
<li>大型、复杂的项目</li>
<li>有快速迭代的需求</li>
<li>访问压力大（微服务去中心化，把业务和数据都拆分了，可以应对访问压力）</li>
</ul>
<h4 id="不适用微服务的场景">不适用微服务的场景</h4>
<ul>
<li>业务稳定</li>
<li>迭代周期长</li>
</ul>
<h3 id="项目演示">项目演示</h3>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/J5duZx_2020_04_04_13_34_50.png" alt="" loading="lazy"></figure>
<h3 id="微服务拆分">微服务拆分</h3>
<ul>
<li>业界流行的拆分方法论</li>
<li>个人心得</li>
<li>合理粒度</li>
<li>小程序的拆分</li>
</ul>
<h4 id="方法论">方法论</h4>
<ul>
<li>
<p>领域驱动设计（Domain Driven Design）(概念太多，学习曲线高)</p>
</li>
<li>
<p>面向对象（by name./by verb）（通过名词（状态），动词（行为）拆分）</p>
</li>
</ul>
<h4 id="个人心得">个人心得</h4>
<h5 id="职责划分">职责划分</h5>
<p>规划好微服务的边界。比如订单微服务只负责订单功能。</p>
<h5 id="通用性划分">通用性划分</h5>
<p>把一些通用功能做成微服务。比如消息中心和用户中心。</p>
<h4 id="合理的粒度">合理的粒度</h4>
<ul>
<li>良好的满足业务（这是前提）</li>
<li>幸福感（你的团队没有人认为微服务太大，难以维护，同时部署也非常高效，不会每次发布都发布N多微服务）</li>
<li>增量迭代</li>
<li>持续进化</li>
</ul>
<h4 id="小程序的拆分">小程序的拆分</h4>
<p>以面向对象方式拆分</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/XeHfxG.png" alt="" loading="lazy"></figure>
<p>用户中心按照通用性划分，内容中心按照职责划分。</p>
<p>项目初期不建议拆分太细，后期如果发现某个微服务过分庞大再细分。</p>
<h4 id="项目架构图">项目架构图</h4>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/uHGDQ8.png" alt="" loading="lazy"></figure>
<h4 id="数据库设计">数据库设计</h4>
<h5 id="数据建模">数据建模</h5>
<h5 id="建表">建表</h5>
<p><strong>user-center-create-table.sql</strong></p>
<pre><code class="language-sql">USE `user_center`;

-- -----------------------------------------------------
-- Table `user`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `user` (
  `id` INT NOT NULL AUTO_INCREMENT COMMENT 'Id',
  `wx_id` VARCHAR(64) NOT NULL DEFAULT '' COMMENT '微信id',
  `wx_nickname` VARCHAR(64) NOT NULL DEFAULT '' COMMENT '微信昵称',
  `roles` VARCHAR(100) NOT NULL DEFAULT '' COMMENT '角色',
  `avatar_url` VARCHAR(255) NOT NULL DEFAULT '' COMMENT '头像地址',
  `create_time` DATETIME NOT NULL COMMENT '创建时间',
  `update_time` DATETIME NOT NULL COMMENT '修改时间',
  `bonus` INT NOT NULL DEFAULT 300 COMMENT '积分',
  PRIMARY KEY (`id`))
COMMENT = '分享';


-- -----------------------------------------------------
-- Table `bonus_event_log`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `bonus_event_log` (
  `id` INT NOT NULL AUTO_INCREMENT COMMENT 'Id',
  `user_id` INT NULL COMMENT 'user.id',
  `value` INT NULL COMMENT '积分操作值',
  `event` VARCHAR(20) NULL COMMENT '发生的事件',
  `create_time` DATETIME NULL COMMENT '创建时间',
  `description` VARCHAR(100) NULL COMMENT '描述',
  PRIMARY KEY (`id`),
  INDEX `fk_bonus_event_log_user1_idx` (`user_id` ASC) )
ENGINE = InnoDB
COMMENT = '积分变更记录表';
</code></pre>
<p><strong>content-center-create-table.sql</strong></p>
<pre><code class="language-sql">USE `content_center`;

-- -----------------------------------------------------
-- Table `share`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `share` (
  `id` INT NOT NULL AUTO_INCREMENT COMMENT 'id',
  `user_id` INT NOT NULL DEFAULT 0 COMMENT '发布人id',
  `title` VARCHAR(80) NOT NULL DEFAULT '' COMMENT '标题',
  `create_time` DATETIME NOT NULL COMMENT '创建时间',
  `update_time` DATETIME NOT NULL COMMENT '修改时间',
  `is_original` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '是否原创 0:否 1:是',
  `author` VARCHAR(45) NOT NULL DEFAULT '' COMMENT '作者',
  `cover` VARCHAR(256) NOT NULL DEFAULT '' COMMENT '封面',
  `summary` VARCHAR(256) NOT NULL DEFAULT '' COMMENT '概要信息',
  `price` INT NOT NULL DEFAULT 0 COMMENT '价格（需要的积分）',
  `download_url` VARCHAR(256) NOT NULL DEFAULT '' COMMENT '下载地址',
  `buy_count` INT NOT NULL DEFAULT 0 COMMENT '下载数 ',
  `show_flag` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '是否显示 0:否 1:是',
  `audit_status` VARCHAR(10) NOT NULL DEFAULT 0 COMMENT '审核状态 NOT_YET: 待审核 PASSED:审核通过 REJECTED:审核不通过',
  `reason` VARCHAR(200) NOT NULL DEFAULT '' COMMENT '审核不通过原因',
  PRIMARY KEY (`id`))
ENGINE = InnoDB
COMMENT = '分享表';


-- -----------------------------------------------------
-- Table `mid_user_share`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `mid_user_share` (
  `id` INT NOT NULL AUTO_INCREMENT,
  `share_id` INT NOT NULL COMMENT 'share.id',
  `user_id` INT NOT NULL COMMENT 'user.id',
  PRIMARY KEY (`id`),
  INDEX `fk_mid_user_share_share1_idx` (`share_id` ASC) ,
  INDEX `fk_mid_user_share_user1_idx` (`user_id` ASC) )
ENGINE = InnoDB
COMMENT = '用户-分享中间表【描述用户购买的分享】';


-- -----------------------------------------------------
-- Table `notice`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `notice` (
  `id` INT NOT NULL AUTO_INCREMENT COMMENT 'id',
  `content` VARCHAR(255) NOT NULL DEFAULT '' COMMENT '内容',
  `show_flag` TINYINT(1) NOT NULL DEFAULT 0 COMMENT '是否显示 0:否 1:是',
  `create_time` DATETIME NOT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`));
</code></pre>
<h4 id="api-文档">API 文档</h4>
<p>课程文档主要分四类：</p>
<ol>
<li>API文档：https://t.itmuch.com/doc.html</li>
<li>课程配套代码：https://git.imooc.com/coding-358/</li>
<li>课程相关资源（例如检表语句、数据模型、课上用到的软件等）：https://git.imooc.com/coding-358/resource</li>
<li>课上用到的一些课外读物（慕课网手记）：http://www.imooc.com/t/1863086</li>
</ol>
<h4 id="如何创建小程序">如何创建小程序</h4>
<p>注册账号：https://mp.weixin.qq.com</p>
<p>按照提示填写信息</p>
<h4 id="前端代码如何使用">前端代码如何使用</h4>
<h4 id="创建项目">创建项目</h4>
<h5 id="技术选型">技术选型</h5>
<ul>
<li>Spring Boot</li>
<li>Spring MVC</li>
<li>Mybatis+通用Mapper</li>
<li>Spring Cloud Alibaba（分布式）</li>
</ul>
<h5 id="工程结构规划">工程结构规划</h5>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/DIgVS4.png" alt="" loading="lazy"></figure>
<h5 id="创建项目整合框架">创建项目，整合框架</h5>
<p>pom.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
	xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
	&lt;parent&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
		&lt;version&gt;2.1.13.RELEASE&lt;/version&gt;
		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
	&lt;/parent&gt;
	&lt;groupId&gt;com.itmuch&lt;/groupId&gt;
	&lt;artifactId&gt;user-center&lt;/artifactId&gt;
	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
	&lt;name&gt;user-center&lt;/name&gt;
	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;

	&lt;properties&gt;
		&lt;java.version&gt;1.8&lt;/java.version&gt;
	&lt;/properties&gt;

	&lt;dependencies&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
		&lt;/dependency&gt;
&lt;!--		引入通用mapper--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
			&lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;
			&lt;version&gt;2.1.5&lt;/version&gt;
		&lt;/dependency&gt;

		&lt;dependency&gt;
			&lt;groupId&gt;mysql&lt;/groupId&gt;
			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
			&lt;scope&gt;runtime&lt;/scope&gt;
		&lt;/dependency&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
			&lt;scope&gt;test&lt;/scope&gt;
			&lt;exclusions&gt;
				&lt;exclusion&gt;
					&lt;groupId&gt;org.junit.vintage&lt;/groupId&gt;
					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;
				&lt;/exclusion&gt;
			&lt;/exclusions&gt;
		&lt;/dependency&gt;
	&lt;/dependencies&gt;

	&lt;build&gt;
		&lt;plugins&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
			&lt;/plugin&gt;
			&lt;plugin&gt;
				&lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;
				&lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;
				&lt;version&gt;1.3.6&lt;/version&gt;
				&lt;configuration&gt;
					&lt;configurationFile&gt;
						${basedir}/src/main/resources/generator/generatorConfig.xml
					&lt;/configurationFile&gt;
					&lt;overwrite&gt;true&lt;/overwrite&gt;
					&lt;verbose&gt;true&lt;/verbose&gt;
				&lt;/configuration&gt;
				&lt;dependencies&gt;
					&lt;dependency&gt;
						&lt;groupId&gt;mysql&lt;/groupId&gt;
						&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
						&lt;version&gt;8.0.19&lt;/version&gt;
					&lt;/dependency&gt;
					&lt;dependency&gt;
						&lt;groupId&gt;tk.mybatis&lt;/groupId&gt;
						&lt;artifactId&gt;mapper&lt;/artifactId&gt;
						&lt;version&gt;4.1.5&lt;/version&gt;
					&lt;/dependency&gt;
				&lt;/dependencies&gt;
			&lt;/plugin&gt;
		&lt;/plugins&gt;
	&lt;/build&gt;

&lt;/project&gt;

</code></pre>
<p>通用Mapper包扫描配置</p>
<pre><code class="language-java">import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import tk.mybatis.spring.annotation.MapperScan;//注意是tk的MapperScan注解

@SpringBootApplication
@MapperScan(&quot;com.itmuch&quot;)
public class UserCenterApplication {

	public static void main(String[] args) {
		SpringApplication.run(UserCenterApplication.class, args);
	}

}
</code></pre>
<p>在resources目录下新建generator目录，添加mybatis.generator配置</p>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/9ijlzo.png" alt="" loading="lazy"></figure>
<p>generator/generatorConfig.xml</p>
<pre><code class="language-xml">&lt;!DOCTYPE generatorConfiguration
        PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt;

&lt;generatorConfiguration&gt;
    &lt;properties resource=&quot;generator/config.properties&quot;/&gt;

    &lt;context id=&quot;Mysql&quot; targetRuntime=&quot;MyBatis3Simple&quot; defaultModelType=&quot;flat&quot;&gt;
        &lt;property name=&quot;beginningDelimiter&quot; value=&quot;`&quot;/&gt;
        &lt;property name=&quot;endingDelimiter&quot; value=&quot;`&quot;/&gt;

        &lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;tk.mybatis.mapper.common.Mapper&quot;/&gt;
            &lt;property name=&quot;caseSensitive&quot; value=&quot;true&quot;/&gt;
        &lt;/plugin&gt;

        &lt;jdbcConnection driverClass=&quot;${jdbc.driverClass}&quot;
                        connectionURL=&quot;${jdbc.url}&quot;
                        userId=&quot;${jdbc.user}&quot;
                        password=&quot;${jdbc.password}&quot;&gt;
        &lt;/jdbcConnection&gt;

        &lt;javaModelGenerator targetPackage=&quot;com.itmuch.usercenter.domain.entity.${moduleName}&quot;
                            targetProject=&quot;src/main/java&quot;/&gt;

        &lt;sqlMapGenerator targetPackage=&quot;com.itmuch.usercenter.dao.${moduleName}&quot;
                         targetProject=&quot;src/main/resources&quot;/&gt;

        &lt;javaClientGenerator targetPackage=&quot;com.itmuch.usercenter.dao.${moduleName}&quot;
                             targetProject=&quot;src/main/java&quot;
                             type=&quot;XMLMAPPER&quot;/&gt;

        &lt;table tableName=&quot;${tableName}&quot;&gt;
            &lt;generatedKey column=&quot;id&quot; sqlStatement=&quot;JDBC&quot;/&gt;
        &lt;/table&gt;
    &lt;/context&gt;
&lt;/generatorConfiguration&gt;
</code></pre>
<p>generator/config.properties</p>
<pre><code class="language-properties">jdbc.driverClass=com.mysql.cj.jdbc.Driver
# nullCatalogMeansCurrent=true 如果不加这个配置，出现表名user在其他库，比如系统库的，会生产系统库的user
jdbc.url=jdbc:mysql://localhost:3306/user_center?nullCatalogMeansCurrent=true
jdbc.user=root
jdbc.password=kim@2020

# 包名
moduleName=user
# 表名
tableName=user
</code></pre>
<p>application.yml</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/user_center
    hikari:
      username: root
      password: kim@2020
      # &gt;=6.x com.mysql.cj.jdbc.Driver
      # &lt;=5.x com.mysql.jdbc.Driver
      driver-class-name: com.mysql.cj.jdbc.Driver
</code></pre>
<p>执行逆向生产代码</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/sezcpm.png" style="zoom:50%;" />
<h4 id="整合lombok简化代码">整合Lombok简化代码</h4>
<pre><code class="language-xml">&lt;dependency&gt;
			&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;
			&lt;artifactId&gt;lombok&lt;/artifactId&gt;
			&lt;version&gt;1.18.10&lt;/version&gt;
			&lt;scope&gt;provided&lt;/scope&gt;
		&lt;/dependency&gt;
</code></pre>
<p>常用注解</p>
<pre><code class="language-java">@Data
@NoArgsConstructor//生成无参构造
@AllArgsConstructor//为所有参数生成构造
@RequiredArgsConstructor//为final属性生成构造方法
@Builder //建造者模式
@Slf4j
</code></pre>
<p>更多查询<a href="https://projectlombok.org/">官网</a></p>
<p>在<a href="https://github.com/abel533/Mapper"><code>通用mapper</code></a> <a href="https://github.com/abel533/Mapper/wiki/4.1.mappergenerator"><code>wiki</code></a>搜<code>lombok</code>，看有没有生成支持<code>lombok</code>的配置</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/5odMfS.png" style="zoom:50%;" />
<h5 id="mybatisgenerator添加lombok支持">mybatis.generator添加lombok支持</h5>
<pre><code class="language-xml">&lt;plugin type=&quot;tk.mybatis.mapper.generator.MapperPlugin&quot;&gt;
            &lt;property name=&quot;mappers&quot; value=&quot;tk.mybatis.mapper.common.Mapper&quot;/&gt;
            &lt;property name=&quot;caseSensitive&quot; value=&quot;true&quot;/&gt;
            &lt;property name=&quot;lombok&quot; value=&quot;Getter,Setter,ToString&quot;/&gt;&lt;!-- 添加的行 --&gt;
        &lt;/plugin&gt;
</code></pre>
<p>文档也说了，目前只支持<code>@Getter@Setter@ToString@Accessors(chain = true)</code>4种注解，一般我们自己的domain上还是习惯加如下注解：</p>
<pre><code class="language-java">@Data
@NoArgsConstructor//生成无参构造
@AllArgsConstructor//为所有参数生成构造
@Builder //建造者模式
</code></pre>
<p>可以手动加，更简单。</p>
<h4 id="解决idea的红色警告">解决IDEA的红色警告</h4>
<p>出现警告的原因：</p>
<p>IDEA是非常智能的，它可以理解Spring的上下文。然而 <code>UserMapper</code> 这个接口是Mybatis的，IDEA理解不了。</p>
<p>而 <code>@Autowired</code> 注解，默认情况下要求依赖对象（也就是 <code>userMapper</code> ）必须存在。而IDEA认为这个对象的实例/代理是个null，所以就<strong>友好地给个提示</strong>。</p>
<p>解决方法：参见这篇<a href="https://www.imooc.com/article/287865">手记</a></p>
<h5 id="作业1-课后研究一下resource和autowired注解">作业1: 课后研究一下@Resource和@Autowired注解</h5>
<h5 id="作业2-研究repository-component-service-controller之间的区别和联系">作业2: 研究@Repository、@Component、@Service、@Controller之间的区别和联系</h5>
<h4 id="编写用户微服务和内容微服务">编写用户微服务和内容微服务</h4>
<p>注意：核心业务，一定要设计好业务流程，分析的过程中，使用业务流程图、活动图、用例图、序列图。重视业务和建模，没有建模的微服务是没有灵魂的。</p>
<h5 id="实际开发流程">实际开发流程</h5>
<p>Schema First</p>
<p>1、分析业务（流程图、用例图...架构图等） 建模业务，确定架构</p>
<p>2、敲定业务流程（评审）</p>
<p>3、设计API/数据模型（表结构设计|类图|ER图）</p>
<p>4、编写API文档</p>
<p>5、编写代码</p>
<p>API First</p>
<p>1、分析业务（流程图、用例图...架构图等） 建模业务，确定架构</p>
<p>2、敲定业务流程（评审）</p>
<p>3、设计API/数据模型（表结构设计|类图|ER图）</p>
<p>4、编写代码</p>
<p>5、编写API文档</p>
<p>但是实际也不是完全按照这样等流程走。</p>
<p>编码。。。</p>
<h5 id="resttemplate的使用">RestTemplate的使用</h5>
<h4 id="现有架构存在的问题">现有架构存在的问题</h4>
<ul>
<li>硬编码IP，IP变化怎么办</li>
<li>如何实现负载均衡？</li>
<li>用户中心挂了怎么办？</li>
</ul>
<h2 id="spring-cloud介绍">Spring Cloud介绍</h2>
<h3 id="什么是spring-cloud-alibaba">什么是Spring Cloud Alibaba</h3>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/s3ySrH.png" alt="" loading="lazy"></figure>
<ul>
<li>Spring Cloud的子项目</li>
<li>致力于提供微服务开发的一站式解决方案
<ul>
<li>包含微服务开发的必备组件</li>
<li>基于Spring Cloud，符合Spring Cloud标准</li>
<li>阿里的微服务解决方案</li>
</ul>
</li>
</ul>
<h3 id="版本与兼容性">版本与兼容性</h3>
<ul>
<li>Spring Cloud 版本命名</li>
<li>Spring Cloud 生命周期</li>
<li>Spring Boot 、Spring Cloud、Spring Cloud Alibaba的兼容性关系</li>
<li>生产环境怎么选择版本？</li>
</ul>
<h4 id="spring-cloud-版本命名">Spring Cloud 版本命名</h4>
<p>语义化</p>
<p>2.1.13.RELEASE</p>
<p>2：主版本，第几代</p>
<p>1：次版本，一些功能的增加，但是架构没有太大变化，是兼容的</p>
<p>13：增量版本，bug修复</p>
<p>RELEASE：里程碑。SNAPSHOT：开发版 ，M：里程碑 ，RELEASE：正式版</p>
<p>Greenwich SR1 ：Greenwich版本的第一个bug修复版</p>
<p>SR：Service Release bug修复</p>
<p>Release Train. 发布列车</p>
<p>伦敦地铁站站名。避免混淆，噱头。</p>
<p>Greenwich RELEASE： Greenwich版本的第一个正式版</p>
<h4 id="spring-cloud-生命周期">Spring Cloud 生命周期</h4>
<ul>
<li>版本发布规划
<ul>
<li>https://github.com/spring-cloud/spring-cloud-release/milestones</li>
</ul>
</li>
<li>版本发布记录
<ul>
<li>https://github.com/spring-cloud/spring-cloud-release/release</li>
</ul>
</li>
<li>版本终止声明
<ul>
<li>https://spring.io/projects/spring-cloud#overview</li>
</ul>
</li>
</ul>
<h4 id="版本兼容性">版本兼容性</h4>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/gF4NW5.png" alt="" loading="lazy"></figure>
<p>https://spring.io/projects/spring-cloud-alibaba#overview</p>
<p>https://github.com/alibaba/spring-cloud-alibaba/blob/master/README-zh.md</p>
<h4 id="生产环境怎么选择版本">生产环境怎么选择版本？</h4>
<ul>
<li>坚决不用非稳定版本/end-of-life版本</li>
<li>尽量用最新一代
<ul>
<li>xxx.RELEASE版本缓一缓</li>
<li>SR2之后一般可大规模使用</li>
</ul>
</li>
</ul>
<h3 id="整合spring-cloud-alibaba">整合Spring Cloud Alibaba</h3>
<ul>
<li><a href="https://cloud.spring.io/spring-cloud-static/Greenwich.SR1/single/spring-cloud.html#_client_side_usage">整合Spring Cloud</a></li>
<li><a href="https://spring.io/projects/spring-cloud-alibaba#overview">整合Spring Cloud Alibaba</a></li>
</ul>
<p>整合好后，引入组件不需要指定版本</p>
<h2 id="服务发现">服务发现</h2>
<h3 id="服务提供者与服务消费者">服务提供者与服务消费者</h3>
<table>
<thead>
<tr>
<th>名次</th>
<th>定义</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务提供者</td>
<td>服务的被调用方（即：为其他微服务提供接口的微服务）</td>
</tr>
<tr>
<td>服务消费者</td>
<td>服务的调用方（即：调用其他微服务接口的微服务）</td>
</tr>
</tbody>
</table>
<h3 id="如何让服务消费者感知到服务提供者">如何让服务消费者感知到服务提供者</h3>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/3iJUdW.png" alt="" loading="lazy"></figure>
<p>服务消费者内部使用定时任务去服务发现组件获取提供者信息，并缓存到本地，服务消费者每次调用服务提供者从本地缓存那提供者信息。</p>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/WNeJFv.png" alt="" loading="lazy"></figure>
<p>添加心跳机制，通过心跳机制改变服务状态</p>
<h3 id="什么是nacos">什么是Nacos</h3>
<p><a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">官网什么是Nacos</a></p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/DDmYIw.png" alt="" loading="lazy"></figure>
<h3 id="搭建nacos-server">搭建Nacos Server</h3>
<p>选择<code>Nacos Server</code>版本</p>
<p>查看引入到<code>spring-cloud-alibaba-dependencie</code>依赖</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/cneRHA.png" style="zoom:63%;" />
<ul>
<li>下载地址
<ul>
<li>https://github.com/alibaba/nacos/releases</li>
</ul>
</li>
<li>搭建Nacos Server
<ul>
<li>参考文档：https://nacos.io/zh-cn/docs/quick-start.html</li>
</ul>
</li>
</ul>
<p>启动服务器</p>
<p><code>startup.sh -m standalone</code></p>
<p>访问控制台</p>
<p>http://localhost:8848/nacos</p>
<p>默认用户名密码都是nacos</p>
<h3 id="将应用注册到nacos">将应用注册到Nacos</h3>
<ul>
<li>用户中心注册到Nacos</li>
<li>内容中心注册到Nacos</li>
<li>测试：内容中心总能找到用户中心</li>
</ul>
<p>引入依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>配置</p>
<pre><code class="language-yaml">spring:
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
  application:
    # 服务名称尽量用-，不要用_，不要用特殊字符
    name: content-center
</code></pre>
<h3 id="引入服务发现">引入服务发现</h3>
<pre><code class="language-java">@Slf4j
@Service
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class ShareService {
    private final ShareMapper shareMapper;

    private final RestTemplate restTemplate;

    private final DiscoveryClient discoveryClient;

    public ShareDto findById(Integer id){
        //获取分享详情
        Share share = this.shareMapper.selectByPrimaryKey(id);
        //发布人id
        Integer userId = share.getUserId();
        //用户中心所有实例的信息
        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(&quot;user-center&quot;);
        String targetURL = instances.stream()
                .map(instance -&gt; instance.getUri().toString() + &quot;/users/{id}&quot;)
                .findFirst()
                .orElseThrow(() -&gt; new IllegalArgumentException(&quot;当前没有实例！&quot;));

        log.info(&quot;请求的目标地址：{}&quot;, targetURL);
        UserDto userDto = restTemplate.getForObject(
                targetURL,
                UserDto.class,
                userId);
        ShareDto shareDto = new ShareDto();

        //消息的装配
        BeanUtils.copyProperties(share, shareDto);
        shareDto.setWxNickName(userDto.getWxNickname());
        return shareDto;
    }
}
</code></pre>
<h3 id="nacos服务发现的领域模型">Nacos服务发现的领域模型</h3>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/IIbYWQ.png" alt="" loading="lazy"></figure>
<p>Namespace：只要用来实现环境隔离，默认public</p>
<p>Group：默认DEFAULT_GROUP，管理服务分组</p>
<p>Service：微服务</p>
<p>Cluster：微服务集群，对指定微服务的虚拟划分</p>
<p>Instance：微服务实例</p>
<h4 id="如何使用">如何使用</h4>
<p>Namespace，在控制台页面创建。配置的时候使用生成的uuid。</p>
<pre><code class="language-yaml">spring:
  cloud:
    nacos:
      discovery:
        # 指定nacos server的地址
        server-addr: localhost:8848
        cluster-name: BJ
        namespace: 56116141-d837-4d15-8842-94e153bb6cfb
</code></pre>
<h3 id="nacos元数据">Nacos元数据</h3>
<ul>
<li>官方描述：https://nacos.io/zh-ch/docs/concepts.html</li>
<li>级别：【服务级别、集群级别、实例级别】</li>
</ul>
<p>元数据的作用：</p>
<ul>
<li>提供描述信息</li>
<li>让微服务调用更灵活
<ul>
<li>例如：微服务版本控制</li>
</ul>
</li>
</ul>
<p>如何为微服务设置元数据</p>
<ul>
<li>控制台界面</li>
<li>配置文件指定</li>
</ul>
<pre><code class="language-yaml">spring:
  cloud:
    nacos:
      discovery:
        # 指定nacos server的地址
        server-addr: localhost:8848
        cluster-name: BJ
        namespace: 56116141-d837-4d15-8842-94e153bb6cfb
        metadata:
          instance: c
          haha: hehe
          version: 1
</code></pre>
<h2 id="实现负载均衡-ribbon">实现负载均衡-Ribbon</h2>
<h3 id="负载均衡的两种方式">负载均衡的两种方式</h3>
<ul>
<li>服务端负载均衡</li>
<li>客户端负载均衡（客户端调用的时候使用选择负载均衡算法）</li>
</ul>
<h3 id="手写一个客户端负载均衡器">手写一个客户端负载均衡器</h3>
<p>改写一下<code>ShareService</code>的<code>findById</code>方法。从<code>Nacos</code>获取到<code>URL</code>列表，然后随机从列表中取一个作为本次请求的服务提供者实例。</p>
<pre><code class="language-java">List&lt;String&gt; targetURLs = instances.stream()
                .map(instance -&gt; instance.getUri().toString() + &quot;/users/{id}&quot;).collect(Collectors.toList());

        int i = ThreadLocalRandom.current().nextInt(targetURLs.size());
        String targetURL= targetURLs.get(i);
</code></pre>
<p>随后启动content-center</p>
<h4 id="启动多个user-center">启动多个user-center</h4>
<p>配置允许并行运行</p>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/Uz9a20.png" alt="" loading="lazy"></figure>
<p>修改端口，运行启动类</p>
<pre><code class="language-yaml">server:
  port: 8082
</code></pre>
<h3 id="使用ribbon实现负载均衡">使用Ribbon实现负载均衡</h3>
<ul>
<li>Ribbon是什么</li>
<li>引入Ribbon后到架构演进</li>
<li>整合Ribbon实现负载均衡</li>
</ul>
<h4 id="ribbon是什么">Ribbon是什么</h4>
<p>负载均衡器</p>
<h4 id="架构演进">架构演进</h4>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/Gjk65Z.png" alt="" loading="lazy"></figure>
<h4 id="整合ribbon实现负载均衡">整合Ribbon实现负载均衡</h4>
<p>引入Nacos</p>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/QOcDIR.png" alt="" loading="lazy"></figure>
<p>我们引入<code>spring-cloud-starter-alibaba-nacos-discovery</code>时，已经引入了<code>Ribbon</code>。</p>
<p>直接使用就行了。</p>
<p>写注解</p>
<pre><code class="language-java">@Bean
@LoadBalanced
public RestTemplate restTemplate(){
  return new RestTemplate();
}
</code></pre>
<p>配置<code>RestTemplate</code>的地方添加<code>@LoadBalanced</code>注解即可。</p>
<h4 id="使用">使用</h4>
<pre><code class="language-java">UserDto userDto = restTemplate.getForObject(
                &quot;http://user-center/users/{userId}&quot;,
                UserDto.class,
                userId);
</code></pre>
<h3 id="ribbon组成">Ribbon组成</h3>
<p><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/jUK5ij.png" alt="" loading="lazy">先有个印象。二次开发再回头看</p>
<h3 id="ribbon内置的负载均衡规则">Ribbon内置的负载均衡规则</h3>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200411121526731.png" alt="" loading="lazy"></figure>
<p>默认是ZoneAvoidanceRule。</p>
<p>每一个负载均衡算法源码都值得看一下。</p>
<h3 id="细粒度配置自定义">细粒度配置自定义</h3>
<ul>
<li>Java代码配置</li>
<li>用配置属性配置</li>
<li>最佳实践总结</li>
</ul>
<p>场景：当内容中心调用用户中心微服务的时候使用随机负载，当内容中心调用其他微服务的时候使用默认负载均衡策略。</p>
<h4 id="java代码配置">Java代码配置</h4>
<p>新建配置类，注册一个RandomRule。</p>
<pre><code class="language-java">package ribbonconfiguration;

import com.netflix.loadbalancer.IRule;
import com.netflix.loadbalancer.RandomRule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * 配置类所在的包必须是和启动类不一样的包
 */
@Configuration
public class RibbonConfiguration {

    @Bean
    public IRule ribbonRule(){
        return new RandomRule();
    }
}
</code></pre>
<p>新建一个<code>user-center</code>的<code>ribbon</code>负载配置类，配置规则使用上面的随机规则。</p>
<pre><code class="language-java">package com.itmuch.contentcenter.configuration;

import org.springframework.cloud.netflix.ribbon.RibbonClient;
import org.springframework.context.annotation.Configuration;
import ribbonconfiguration.RibbonConfiguration;

@Configuration
@RibbonClient(name = &quot;user-center&quot;,configuration = RibbonConfiguration.class)
public class UserCenterRibbonConfiguration {
}
</code></pre>
<p><code>@RibbonClient</code>注解配置<code>Ribbon</code>自定义配置</p>
<p><code>name=&quot;user-center&quot;</code>表示为<code>user-center</code>配置的。</p>
<p><code>configuration = RibbonConfiguration.class</code>用来指定负载均衡算法，或者负载均衡规则</p>
<h5 id="父子上下文">父子上下文</h5>
<p>这里的上下文是指<code>Spring Context</code>。</p>
<p>启动类拥有一个上下文，是父上下文，Ribbon会启动一个子上下文，<strong>父子上下文不能重叠</strong>。</p>
<p>启动类的上下文，会扫描启动类所在包及子包下的Bean。</p>
<p><code>Ribbon</code>的配置类不能被启动类的上下文扫描到。因为<code>Spring context</code>是一个树状上下文。父子上下文扫描到包如果重叠会有各种问题。比如，<a href="https://blog.csdn.net/qq_32588349/article/details/52097943"><strong>导致事务不生效</strong></a>。</p>
<p><strong>如果上面配置的RibbonConfiguration在启动类扫描范围内，会导致自定义配置失效，RibbonConfiguration配置的随机负载均衡全局生效。</strong></p>
<h4 id="配置属性方式">配置属性方式</h4>
<pre><code class="language-yaml">user-center:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
</code></pre>
<p>这种方式没有上下文重叠的坑</p>
<h4 id="两种配置方式的对比">两种配置方式的对比</h4>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200411175449054.png" alt="image-20200411175449054" loading="lazy"></figure>
<h4 id="细粒度配置最佳实践">细粒度配置最佳实践</h4>
<ul>
<li>尽量使用属性配置，属性方式实现不了的情况下再考虑用代码配置</li>
<li>在同一个微服务内尽量保持单一性，比如统一使用属性配置，不要两种方式混用，增加定位代码的复杂性</li>
</ul>
<h3 id="全局配置">全局配置</h3>
<ul>
<li>方式一：让<code>ComponentScan</code>上下文重叠（强烈不建议使用）</li>
<li>方式二：唯一正确的途径：<code>@RibbonClients(defaultConfiguration = xxx.class)</code></li>
</ul>
<pre><code class="language-java">package com.itmuch.contentcenter.configuration;

import org.springframework.cloud.netflix.ribbon.RibbonClients;
import org.springframework.context.annotation.Configuration;
import ribbonconfiguration.RibbonConfiguration;

@Configuration
@RibbonClients(defaultConfiguration = RibbonConfiguration.class)
public class UserCenterRibbonConfiguration {
}
</code></pre>
<h3 id="支持的配置项">支持的配置项</h3>
<p>Java Config方式：见<code>Ribbon组成</code>一节的接口</p>
<p>配置文件方式：</p>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200411180522524.png" alt="image-20200411180522524" loading="lazy"></figure>
<h3 id="饥饿加载">饥饿加载</h3>
<p>默认是懒加载，在调用<code>restTemplate</code>时才会创建一个叫<code>user-center</code>的<code>Ribbon Client</code></p>
<blockquote>
<p><code>user-center</code>是要调用的客户端名字</p>
</blockquote>
<p>懒加载的问题：在第一次调用<code>user-center</code>的接口时，访问会慢。</p>
<p>可以使用饥饿加载避免这个问题。</p>
<pre><code class="language-yaml">ribbon:
  eager-load:
    enabled: true
    clients: user-center
</code></pre>
<h3 id="扩展ribbon">扩展Ribbon</h3>
<h4 id="支持nacos权重">支持Nacos权重</h4>
<p>首先了解一下，Nacos的权重在<code>0-1</code>之间，<code>1</code>最大</p>
<p>Ribbon内置的负载均衡规则都不支持Nacos的权重，需要自己定义一个负载均衡规则。</p>
<pre><code class="language-java">@Slf4j
public class NacosWeightedRule extends AbstractLoadBalancerRule {

    @Autowired
    private NacosDiscoveryProperties nacosDiscoveryProperties;

    @Override
    public void initWithNiwsConfig(IClientConfig iClientConfig) {
        //读取配置文件，并初始化当前配置NacosWeightedRule，一般不需要实现
    }

    @Override
    public Server choose(Object key) {
        BaseLoadBalancer loadBalancer = (BaseLoadBalancer) this.getLoadBalancer();
        log.info(&quot;loadBalancer = {}&quot;, loadBalancer);

        //想要请求的微服务的名称
        String name = loadBalancer.getName();

        //实现负载均衡算法
        //这里不自己实现，直接使用nacos提供的
        //拿到服务发现的相关API
        NamingService namingService = nacosDiscoveryProperties.namingServiceInstance();
        try {
            Instance instance = namingService.selectOneHealthyInstance(name);
            log.info(&quot;选择的实例是：port = {}, instance = {}&quot;, instance.getPort(), instance);
            return new NacosServer(instance);
        } catch (NacosException e) {
            return null;
        }
    }
}
</code></pre>
<p>配置为全局规则</p>
<pre><code class="language-java">/**
 * 配置类所在的包必须是和启动类不一样的包
 */
@Configuration
public class RibbonConfiguration {

    @Bean
    public IRule ribbonRule(){
        return new NacosWeightedRule();
    }
}
</code></pre>
<p>更多扩展方式可以<a href="https://www.imooc.com/article/288660"><strong>扩展Ribbon支持Nacos权重的三种方式</strong></a></p>
<h4 id="同一集群优先调用">同一集群优先调用</h4>
<p>为了实现容灾，把内容中心和用户中心部署在北京机房和南京机房里，希望调用的时候同机房优先。</p>
<p>使用Nacos服务发现领域模型里的Cluster</p>
<p>编写同集群优先调用规则</p>
<pre><code class="language-java">@Slf4j
public class NacosSameClusterWeightedRule extends AbstractLoadBalancerRule {
    @Autowired
    private NacosDiscoveryProperties nacosDiscoveryProperties;
    @Override
    public void initWithNiwsConfig(IClientConfig iClientConfig) {

    }

    @Override
    public Server choose(Object key) {
        //拿到配置文件中的集群名称
        String clusterName = nacosDiscoveryProperties.getClusterName();
        BaseLoadBalancer loadBalancer = (BaseLoadBalancer) this.getLoadBalancer();
        log.info(&quot;loadBalancer = {}&quot;, loadBalancer);

        //想要请求的微服务的名称
        String name = loadBalancer.getName();

        //拿到服务发现的相关API
        NamingService namingService = nacosDiscoveryProperties.namingServiceInstance();
        try {
            //1 找到指定服务的所有实例
            List&lt;Instance&gt; instances = namingService.selectInstances(name, true);
            //2 过滤出相同集群下的所有实例
            Stream&lt;Instance&gt; instanceStream = instances.stream()
                    .filter(instance -&gt; Objects.equals(instance.getClusterName(), clusterName));
            List&lt;Instance&gt; sameClusterInstances = instanceStream.collect(Collectors.toList());

            List&lt;Instance&gt; instancesToBeChosen;
            if(CollectionUtils.isEmpty(sameClusterInstances)){
                instancesToBeChosen = instances;
                log.warn(&quot;发生跨集群调用，name = {}, clusterName = {}, instances = {}&quot;,
                        name,
                        clusterName,
                        instances);
            }else {
                instancesToBeChosen = sameClusterInstances;
            }
            //3 基于权重的负载均衡算法，返回1个实例
            Instance instance = ExtendBalancer.getHostByRandomWeight2(instancesToBeChosen);
            log.info(&quot;选择的实例是 port = {}, instances = {} &quot;,instance.getPort(), instance);

            return new NacosServer(instance);
        } catch (NacosException e) {
            log.error(&quot;发生异常&quot;,e);
        }
        return null;
    }
}

class ExtendBalancer extends Balancer{
    //Nacos没有暴露从实例列表中选一个，只有selectOneHealthyInstance
    public static Instance getHostByRandomWeight2(List&lt;Instance&gt; hosts) {
        return getHostByRandomWeight(hosts);
    }
}
</code></pre>
<p>配置全局<code>NacosSameClusterWeightedRule</code></p>
<pre><code class="language-java">@Configuration
public class RibbonConfiguration {

    @Bean
    public IRule ribbonRule(){
        return new NacosSameClusterWeightedRule();
    }
}
</code></pre>
<p>配置所在集群</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/content_center
    hikari:
      username: root
      password: kim@2020
      # &gt;=6.x com.mysql.cj.jdbc.Driver
      # &lt;=5.x com.mysql.jdbc.Driver
      driver-class-name: com.mysql.cj.jdbc.Driver
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        cluster-name: BJ
  application:
    # 服务名称尽量用-，不要用_，不要用特殊字符
    name: content-center

logging:
  level:
    com.itmuch.usercenter.dao.content: debug

server:
  servlet:
    context-path:
  port: 8010

#user-center:
#  ribbon:
#    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
ribbon:
  eager-load:
    enabled: true
    clients: user-center
</code></pre>
<p>启动内容中心服务</p>
<p>接下来，配置两个用户中心服务，分别配置不同的集群和端口</p>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/user_center
    hikari:
      username: root
      password: kim@2020
      # &gt;=6.x com.mysql.cj.jdbc.Driver
      # &lt;=5.x com.mysql.jdbc.Driver
      driver-class-name: com.mysql.cj.jdbc.Driver
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        # 多集群配置
        cluster-name: BJ
  application:
    # 服务名称尽量用-，不要用_，不要用特殊字符
    name: user-center

logging:
  level:
    com.itmuch.usercenter.dao.user: debug
server:
  # 本地启动多个实例，启动前记得改端口
  port: 8081
</code></pre>
<p>查看Nacos控制台</p>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412103656785.png" alt="image-20200412103656785" loading="lazy"></figure>
<p>观察到<code>user-center</code>的集群数目是2。点击详情</p>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412103753967.png" alt="image-20200412103753967" loading="lazy"></figure>
<p>页面访问请求http://localhost:8010/shares/1</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412103847501.png" alt="image-20200412103847501" style="zoom:50%;" />
<p>可以看到总是请求到相同机房的实例（8081也属于BJ集群）。</p>
<p>模拟BJ集群下线。选择Nacos控制台里BJ集群的8081实例，将其下线。</p>
<p>再次浏览器访问http://localhost:8010/shares/1</p>
<p>可以观察到已经请求到了异地机房的NJ机房的实例8082</p>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412104229107.png" alt="image-20200412104229107" loading="lazy"></figure>
<h4 id="番外为开源项目贡献代码">番外：为开源项目贡献代码</h4>
<p>目前同集群优先调用规则已经在新版本中被采纳了，可以直接配置。我用的是2.1.0.RELEASE版本</p>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412104443239.png" alt="image-20200412104443239" loading="lazy"></figure>
<p>同集群优先调用规则的类是<code>com.alibaba.cloud.nacos.ribbon.NacosRule</code>,直接配置这个类使用，不需要再扩展了。</p>
<h3 id="基于元数据的版本控制">基于元数据的版本控制</h3>
<p>配置元数据，只要在<code>spring.cloud.nacos.discovery.metadata</code>下配置<code>key-value</code>对就可以</p>
<pre><code class="language-yaml">spring:
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        cluster-name: BJ
        metadata:
          version: v1.0
</code></pre>
<p>核心逻辑是，服务提供者和服务消费者配置相同的或不同的<code>version</code>元数据，在服务消费者请求服务提供者的时候，从待选实例中过滤一下，找到相同版本号的实例列表，再用一种负载算法从从版本号列表中选一个实例。</p>
<pre><code class="language-java">String version = nacosDiscoveryProperties.getMetadata().get(&quot;version&quot;);
NamingService namingService = nacosDiscoveryProperties.namingServiceInstance();
        try {
            //1 找到指定服务的所有实例
            List&lt;Instance&gt; instances = namingService.selectInstances(name, true);
            //过滤出同集群的实例列表
            //过滤出版本号相同的实例列表
            List&lt;Instance&gt; sameVersionInstances = instancesToBeChosen.stream()
                    .filter(instance -&gt; Objects.equals(instance.getMetadata().get(&quot;version&quot;), version))
                    .collect(Collectors.toList());
            //从列表中选出一个实例
          Instance instance = ExtendBalancer.getHostByRandomWeight2(instancesToBeChosen);
</code></pre>
<p>具体实现参见<a href="https://www.imooc.com/article/288674">手记</a></p>
<h3 id="深入理解namespace">深入理解Namespace</h3>
<p>配置namespace</p>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412110517289.png" alt="image-20200412110517289" loading="lazy"></figure>
<pre><code class="language-yaml">spring:
  datasource:
    url: jdbc:mysql://localhost:3306/content_center
    hikari:
      username: root
      password: kim@2020
      # &gt;=6.x com.mysql.cj.jdbc.Driver
      # &lt;=5.x com.mysql.jdbc.Driver
      driver-class-name: com.mysql.cj.jdbc.Driver
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        cluster-name: BJ
        metadata:
          version: v1.0
        # 指定namespace
        namespace: bc4f4e1a-bf4e-4bcc-86f1-7f6252f81e45
  application:
    # 服务名称尽量用-，不要用_，不要用特殊字符
    name: content-center
</code></pre>
<p>跨namespace不能调用</p>
<p>在用户中心和内容中心分别配上同样的命名空间ID。才可以正常访问。</p>
<h3 id="现有架构存在的问题-2">现有架构存在的问题</h3>
<ol>
<li>代码不可读</li>
<li>复杂的url难以维护</li>
<li>难以响应需求变化，变化没有幸福感</li>
<li>编程体验不统一</li>
</ol>
<h2 id="声明式http客户端feign">声明式HTTP客户端Feign</h2>
<ul>
<li>Feign是Netflix开源的声明式HTTP客户端</li>
<li>Github地址
<ul>
<li>https://github.com/openfeign/feign</li>
</ul>
</li>
</ul>
<h3 id="使用feign实现远程http调用">使用Feign实现远程HTTP调用</h3>
<h4 id="引入依赖">引入依赖</h4>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<h4 id="写注解">写注解</h4>
<p>启动类上加上<code>@EnableFeignClients</code>注解</p>
<h4 id="写配置">写配置</h4>
<p>暂时没有</p>
<p>实现一个Feign接口</p>
<pre><code class="language-java">@FeignClient(name = &quot;user-center&quot;)
public interface UserCenterFeignClient {

    /**
     * http://user-center/users/{id}
     * @param id
     * @return
     */
    @GetMapping(&quot;/users/{id}&quot;)
    UserDto findById(@PathVariable Integer id);
}
</code></pre>
<pre><code class="language-java">@Slf4j
@Service
@RequiredArgsConstructor(onConstructor = @__(@Autowired))
public class ShareService {
    private final ShareMapper shareMapper;

    private final UserCenterFeignClient userCenterFeignClient;

    public ShareDto findById(Integer id){
        //获取分享详情
        Share share = this.shareMapper.selectByPrimaryKey(id);
        //发布人id
        Integer userId = share.getUserId();

        UserDto userDto = this.userCenterFeignClient.findById(userId);
        ShareDto shareDto = new ShareDto();

        //消息的装配
        BeanUtils.copyProperties(share, shareDto);
        shareDto.setWxNickName(userDto.getWxNickname());
        return shareDto;
    }
}
</code></pre>
<p>所谓的声明式HTTP客户端，就是只需要声明一个Feign Client接口，Feign就会根据声明的接口，自动帮我们构造请求的目标地址，并帮助你请求。</p>
<h3 id="feign的组成">Feign的组成</h3>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412165849453.png" alt="image-20200412165849453" loading="lazy"></figure>
<h3 id="细粒度配置自定义-2">细粒度配置自定义</h3>
<p>默认Feign不打印任何日志，可以自定义Feign日志级别，让其打印日志</p>
<p>Feign日志级别</p>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412170429751.png" alt="image-20200412170429751" loading="lazy"></figure>
<h4 id="java配置方式">Java配置方式</h4>
<p>UserCenterFeignConfiguration</p>
<pre><code class="language-java">/**
 * feign的配置类，最佳实践不要加@Configuration注解，否则必须挪到@ComponentScan能扫描的包以外。
 * 是因为重复扫描，父子上下文的问题
 */
public class UserCenterFeignConfiguration {

    @Bean
    public Logger.Level level(){
        //打印所有请求的细节
        return Logger.Level.FULL;
    }
}
</code></pre>
<p>UserCenterFeignClient</p>
<pre><code class="language-java">@FeignClient(name = &quot;user-center&quot;, configuration = UserCenterFeignConfiguration.class)
public interface UserCenterFeignClient {

    /**
     * http://user-center/users/{id}
     * @param id
     * @return
     */
    @GetMapping(&quot;/users/{id}&quot;)
    UserDto findById(@PathVariable Integer id);
}
</code></pre>
<pre><code class="language-yaml">logging:
  level:
    com.itmuch.usercenter.dao.content: debug
    com.itmuch.contentcenter.feignclient.UserCenterFeignClient: debug
</code></pre>
<h4 id="属性方式配置">属性方式配置</h4>
<pre><code class="language-yaml">feign:
  client:
    config:
      # 想要调用的微服务的名称
      user-center:
        loggerLevel: full
</code></pre>
<h3 id="全局配置-2">全局配置</h3>
<h4 id="代码方式">代码方式</h4>
<p>将细粒度的配置方式都注释掉</p>
<p>在启动类配置上全局配置</p>
<pre><code class="language-java">@EnableFeignClients(defaultConfiguration = UserCenterFeignConfiguration.class)
</code></pre>
<h4 id="配置属性方式-2">配置属性方式</h4>
<pre><code class="language-yaml">feign:
  client:
    config:
      default:
        loggerLevel: full
</code></pre>
<h3 id="支持的配置项-2">支持的配置项</h3>
<p>代码方式</p>
<figure data-type="image" tabindex="31"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412173444979.png" alt="image-20200412173444979" loading="lazy"></figure>
<p>属性配置方式</p>
<figure data-type="image" tabindex="32"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412173508756.png" alt="image-20200412173508756" loading="lazy"></figure>
<h3 id="配置最佳实践">配置最佳实践</h3>
<h4 id="ribbon配置-vs-feign配置">Ribbon配置 vs Feign配置</h4>
<p>Ribbon是一个负载均衡器，帮我们选择一个实例</p>
<p>Feign是一个声明式HTTP客户端，帮助我们更优雅的请求</p>
<figure data-type="image" tabindex="33"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412175511967.png" alt="image-20200412175511967" loading="lazy"></figure>
<h4 id="feign代码方式vs属性方式">Feign代码方式vs属性方式</h4>
<figure data-type="image" tabindex="34"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412175730431.png" alt="image-20200412175730431" loading="lazy"></figure>
<p>优先级：全局代码&lt;全局属性&lt;细粒度代码&lt;细粒度属性</p>
<h4 id="最佳实践-3">最佳实践</h4>
<ul>
<li>尽量使用属性配置，属性方式实现不了的情况再考虑用代码配置</li>
<li>在同一个微服务内尽量保持单一性，比如统一使用属性配置，不要两种方式混用，增加定位代码的复杂性</li>
</ul>
<h3 id="feign的继承">Feign的继承</h3>
<p>这个特性带来了紧耦合，因为在微服务间共享接口，官方不建议使用。</p>
<p>现状：很多公司用，代码复用。</p>
<p>新项目如何选择：权衡利弊，会得到什么好处，失去什么，是不是划算，划算就上。</p>
<h3 id="多参数请求构造">多参数请求构造</h3>
<p><a href="https://www.imooc.com/article/289000">如何使用Feign构造多参数的请求</a></p>
<p>Get请求参数使用@SpringQueryMap注解</p>
<pre><code class="language-java">@FeignClient(name = &quot;user-center&quot;)
public interface TestUserCenterFeignClient {

    @GetMapping(&quot;/q&quot;)
    UserDto query(@SpringQueryMap UserDto userDto);
}
</code></pre>
<p>Post请求多参数，也可以使用@RequestBody。</p>
<h3 id="feign脱离ribbon使用">Feign脱离Ribbon使用</h3>
<pre><code class="language-java">@FeignClient(name = &quot;baidu&quot;, url=&quot;http://www.baidu.com&quot;)
public interface TestBaiduFeignClient {

    @GetMapping(&quot;&quot;)
    String index();
}
</code></pre>
<pre><code class="language-java">@GetMapping(&quot;baidu&quot;)
    public String baiduIndex(){
        return this.testBaiduFeignClient.index();
    }
</code></pre>
<h3 id="resttemplate-vs-feign">RestTemplate vs Feign</h3>
<figure data-type="image" tabindex="35"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412205018818.png" alt="image-20200412205018818" loading="lazy"></figure>
<p>如何选择？</p>
<ul>
<li>原则：尽量用Feign，杜绝使用RestTemplate</li>
</ul>
<p>尽量减少开发人员的选择，共存会带来风格的不统一，额外的学习成本和额外的代码理解成本</p>
<ul>
<li>事无绝对，合理选择</li>
</ul>
<p>Feign解决不了，才用RestTemplate</p>
<h3 id="feign的性能优化">Feign的性能优化</h3>
<ul>
<li>连接池【提升15%左右】，默认使用URLConnection，可以修改</li>
</ul>
<p>可以选用httpclient或者okhttp</p>
<p>添加依赖</p>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
            &lt;artifactId&gt;feign-httpclient&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt;
            &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<pre><code class="language-yaml">feign:
  client:
    config:
      default:
        loggerLevel: full
  httpclient:
    # 让feign使用apache httpclient做请求，而不是默认的urlclient
    enabled: true
    # feign的最大连接数
    max-connections: 200
    # feign单个路径的最大连接数
    max-connections-per-route: 50
  okhttp:
    enabled: true
    # feign的最大连接数
    max-connections: 200
    # feign单个路径的最大连接数
    max-connections-per-route: 50
</code></pre>
<ul>
<li>日志级别</li>
</ul>
<p>生产环境建议设置为basic</p>
<h3 id="feign常见问题总结">Feign常见问题总结</h3>
<p><a href="https://www.imooc.com/article/289005">常见问题总结</a></p>
<h3 id="现有架构总结">现有架构总结</h3>
<figure data-type="image" tabindex="36"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412210834103.png" alt="image-20200412210834103" loading="lazy"></figure>
<h2 id="服务容错-sentinel">服务容错-Sentinel</h2>
<p>雪崩效应：基础服务故障，导致导致上层服务故障，并且故障不断放大。又称为cascading failure，级联失效，级联故障。</p>
<figure data-type="image" tabindex="37"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200412211328332.png" alt="image-20200412211328332" loading="lazy"></figure>
<p>雪崩效应是因为服务没有做好容错。</p>
<h3 id="常见的容错方案容错思想">常见的容错方案（容错思想）</h3>
<ul>
<li>超时</li>
<li>限流</li>
<li>仓壁模式（线程池隔离）</li>
<li>断路器模式</li>
</ul>
<p>5秒内错误率、错误次数达到就跳闸。</p>
<p>断路器三态：</p>
<figure data-type="image" tabindex="38"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200418230211926.png" alt="image-20200418230211926" loading="lazy"></figure>
<h3 id="使用sentinel实现容错">使用Sentinel实现容错</h3>
<p>是什么：轻量级的流量控制、熔断降级Java库。</p>
<h3 id="整合sentinel">整合Sentinel</h3>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>可以使用/actuator/sentinel断点查看sentinel相关信息。</p>
<h3 id="整合actuator">整合Actuator</h3>
<pre><code class="language-xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
<p>需要加入配置才能暴露sentinel端点。</p>
<pre><code class="language-yaml">management:
  endpoints:
    web:
      exposure:
        include: '*'
</code></pre>
<h3 id="sentinel控制台">Sentinel控制台</h3>
<h4 id="搭建sentinel控制台">搭建Sentinel控制台</h4>
<p>https://github.com/alibaba/Sentinel/releases</p>
<p>生产环境，控制台版本最好和整体版本一致。</p>
<p>启动sentinel控制台</p>
<p><code>java -jar /Users/kim/Downloads/sentinel-dashboard-1.7.2.jar</code></p>
<p>默认在localhost:8080端口，用户名密码都是sentinel。</p>
<p>为内容中心整合sentinel控制台</p>
<pre><code class="language-yaml"># 指定sentinel 控制台地址
spring.cloud.sentinel.transport.dashboard: localhost:8080
</code></pre>
<p>确保nacos、sentinel控制台、内容中心和用户中心都启动了。然后访问http://localhost:8010/shares/1多次，就可以在实时监控里看到效果。</p>
<figure data-type="image" tabindex="39"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200418233034998.png" alt="image-20200418233034998" loading="lazy"></figure>
<h3 id="流控规则">流控规则</h3>
<p>点击簇点链路，点击/shares/1的流控按钮，就可以为这个访问路径设置流控规则。</p>
<figure data-type="image" tabindex="40"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419110648290.png" alt="image-20200419110648290" loading="lazy"></figure>
<figure data-type="image" tabindex="41"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419110733958.png" alt="image-20200419110733958" loading="lazy"></figure>
<h4 id="资源名">资源名</h4>
<p>默认是请求路径。</p>
<h4 id="针对来源">针对来源</h4>
<p>针对调用者限流。针对来源是调用者微服务名称。</p>
<h4 id="阈值类型">阈值类型</h4>
<p>QPS、线程数。比如选择QPS，表示：当调用当前资源的QPS达到阈值时，就去限流。</p>
<h4 id="是否集群">是否集群</h4>
<h4 id="流控模式">流控模式</h4>
<h5 id="直接">直接</h5>
<h5 id="关联">关联</h5>
<p><code>&lt;1&gt;</code>当关联的资源达到阈值，就限流自己</p>
<p>比如我们设置关联资源为<code>/actuator/sentinel</code>，当关联资源的qps达到1时，就限流<code>/shares/1</code></p>
<figure data-type="image" tabindex="42"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419120020951.png" alt="image-20200419120020951" loading="lazy"></figure>
<p>写一个测试类，调用<code>/actuator/sentinel</code></p>
<pre><code class="language-java">public class SentinelTest {
    public static void main(String[] args) throws InterruptedException {
        RestTemplate restTemplate = new RestTemplate();
        for (int i = 0; i &lt; 10000; i++) {
            String forObject = restTemplate.getForObject(&quot;http://localhost:8010/actuator/sentinel&quot;, String.class);
            Thread.sleep(500);
        }
    }
}
</code></pre>
<p>运行这个测试类，再去调用<code>/shares/1</code>,发信啊已经被限流了。</p>
<figure data-type="image" tabindex="43"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419121201930.png" alt="image-20200419121201930" loading="lazy"></figure>
<p>实际应用，如果希望修改优先，可以配置关联API为修改的API，资源名设置为查询的API。当修改的测试过多，就限流查询，保证性能。</p>
<h5 id="链路">链路</h5>
<p>只记录指定链路上的流量</p>
<h4 id="流控效果">流控效果</h4>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网课分享]]></title>
        <id>https://xinrong2019.github.io/post/wang-ke/</id>
        <link href="https://xinrong2019.github.io/post/wang-ke/">
        </link>
        <updated>2020-03-25T11:45:12.000Z</updated>
        <content type="html"><![CDATA[<p>斯坦福网络安全课</p>
<p>https://web.stanford.edu/class/cs253/</p>
<p>高级数据结构</p>
<p>https://courses.csail.mit.edu/6.851/fall17/lectures/</p>
<p>MIT计算机科学</p>
<p>https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[是不是很酷文章摘录]]></title>
        <id>https://xinrong2019.github.io/post/shi-bu-shi-hen-ku-wen-zhang-zhai-lu/</id>
        <link href="https://xinrong2019.github.io/post/shi-bu-shi-hen-ku-wen-zhang-zhai-lu/">
        </link>
        <updated>2020-03-25T11:44:00.000Z</updated>
        <content type="html"><![CDATA[<h2 id="关于提升瓶颈的问题">关于提升瓶颈的问题</h2>
<p>关于提升瓶颈的问题，可以参考这个问答：https://t.zsxq.com/uRJauBi</p>
<p>如果你做了四年安卓，感觉“技术就那样”，转去做前端，近乎一定也是“就那样”。当然，如果你接触前端，发现你更喜欢前端技术的话，慢慢转去做前端没问题。但具体在什么技术领域，应该不是你现阶段发展的瓶颈。 我的建议是，向上发展，而不是领域迁移。</p>
<p>什么叫向上发展？</p>
<p>选定安卓或者前端某一个技术领域，去研究大厂的高级别的技术职位，需要达到什么标准？他们简历关看什么？期望你有什么经历？什么技术水平？笔试考什么？对应什么知识？面试又面什么？需要你达到什么水平？找到自己的差距，开始向这个标准努力。</p>
<p>或者，如果对管理岗感兴趣的话，研究一下，在自己所在的企业，从你现在的level，怎么往上升？怎么成为你所在组的 leader？甚至成为整个技术部门的 leader？自己还差什么？</p>
<p>不是说要你争名夺利。而是说，眼睛应该往更高的地方去看，去思考，去想，去研究，那些你期望的岗位上的人，他们到底为什么能走到那里？他们和自己的差别在哪里？一旦找到这个差别，努力就好了。</p>
<p>我公众号上转载的一篇文章，给你提供一个可能的方向参考：</p>
<p>https://mp.weixin.qq.com/s/gzZU-pk-aJNUk0vEixtHPA</p>
<h2 id="关于语言选择的问题">关于语言选择的问题</h2>
<p>关于语言选择的问题，可以参考这个问答：https://t.zsxq.com/ufAieAy</p>
<p>不要选择语言，而是选择领域。</p>
<p>不过你刚大二，说实话，不用想这么多。依托一两个语言，把基础知识学好，真的最重要。 什么是基础知识？算法，数据结构，操作系统，软件工程，网络，数据库，计算机底层原理（可以参考这里：https://mp.weixin.qq.com/s/h9mnGmIUoht7zRtDh6XD-g ），数学（离散数学为主），等等等等。 这些课程应该也是你们现在课程设计的中心。 这些学好了，应用层的开发真的很简单。你去大厂工作也好，将来考研究生也好，就会发现，主要考查的，也是这些基础内容。 更重要的是，等你真的开始吃技术这碗饭的时候，爬得越高，越会意识到，这些基础知识的掌握，决定着你的技术上限。 加油！：）</p>
<p>系统开发，推荐算法，图像，后端，这些都是方向。C++不是方向，Java同理。</p>
<p>任何语言本身不是一个学习的方向。</p>
<p>一个值钱的架构师，道路应该是陡峭的：但从另一个角度看，任何一个值钱的职业，都应该是陡峭的，不容易的。所以，我建议在选择职业道路的时候，不要想难度。第一看自己的兴趣；第二看市场的需求。 我认为优秀的架构师长期有巨大的市场需求。至于你的兴趣是否在这里，只有你自己知道。</p>
<p>如何应对大龄危机，是一个太过宽泛的问题。我不认为存在一个万能之法，使用它就解决大龄危机问题了。如果这个方法存在的话，大龄危机就不是一个问题了。 关于大龄问题，我也一直在思考，以后可能会形成一篇甚至几篇公众号文章。 不过现在，我对这个问题也没什么经验，毕竟我才 34 岁，还年轻的很：）</p>
<h2 id="天生不聪明">天生不聪明</h2>
<p>https://mp.weixin.qq.com/s/QvXIDpyrpiOmvEhcOUUmxQ</p>
<h3 id="对聪明的不同看法会影响人的表现和行为发展">对聪明的不同看法，会影响人的表现和行为发展。</h3>
<p>聪明到底是天生的？还是后天学习来的？</p>
<p>认为聪明是后天学习来的孩子，学习成绩明显的高于相信聪明是天生的孩子。</p>
<p>相信聪明是天生的学生，数学成绩持续下降；而那些相信聪明是后天的学习可以弥补的学生，数学成绩是不降反升的！</p>
<h3 id="认知神经科学基础课和补习班">认知神经科学基础课和补习班</h3>
<p>“补习班”——讲解具体的数学知识点。数学考不好？来来来，课后我们多做点儿练习。</p>
<p>“认知神经科学”基础课。课程的内容，主要就是向大家传授当前认知神经科学的最新研究成果：人类的大脑是如何学习到知识的？答案是通过不断的思考。在不断地学习和思考的过程中，人的大脑内部产生着剧烈的神经活动，迫使脑神经之间建立了更多的连接。随着神经元之间连接越来越多，我们对问题的认识也就越来越深刻，遇到类似问题反应也会越来越快。不仅如此，甚至还能触类旁通，举一反三，乃至和其他的领域结合，产生创新性的想法。这表现出来，就是你更聪明了。</p>
<blockquote>
<p><a href="%5Bhttps://zh.wikipedia.org/wiki/%E7%BB%B4%E7%94%9F%E7%B4%A0B%5D(https://zh.wikipedia.org/wiki/%E7%BB%B4%E7%94%9F%E7%B4%A0B)">维生素B族</a>都是<strong>水溶性维生素</strong>，它们有协同作用，调节<a href="https://zh.wikipedia.org/wiki/%E6%96%B0%E9%99%B3%E4%BB%A3%E8%AC%9D">新陈代谢</a>，维持<a href="https://zh.wikipedia.org/wiki/%E7%9A%AE%E8%82%A4">皮肤</a>和<a href="https://zh.wikipedia.org/wiki/%E8%82%8C%E8%82%89">肌肉</a>的健康，增进<a href="https://zh.wikipedia.org/wiki/%E5%85%8D%E7%96%AB%E7%B3%BB%E7%BB%9F">免疫系统</a>和<a href="https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E7%B3%BB%E7%BB%9F">神经系统</a>的功能，促进<a href="https://zh.wikipedia.org/wiki/%E7%BB%86%E8%83%9E">细胞</a>生长和<a href="https://zh.wikipedia.org/wiki/%E7%BB%86%E8%83%9E%E5%88%86%E8%A3%82">分裂</a>（包括促进<a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E8%A1%80%E7%90%83">红血球</a>的产生，预防<a href="https://zh.wikipedia.org/wiki/%E8%B4%AB%E8%A1%80">贫血</a>发生）。其中维生素B1、B6和B12有助保护神经组织细胞，维生素B2则具有抗氧化作用，而植物能合成维生素B2，动物一般不能合成，必须由食物获得维生素B2，而维生素B2是维持动物正常生长所必需的元素之一，如果缺乏则有可能造成生长停顿，或局部损害。</p>
<p>补充维生素B不会让你更聪明，但是会在你需要的时候促进神经系统产生连接。</p>
</blockquote>
<p>我们对聪明的看法，会影响，甚至是严重影响我们的表现！</p>
<p>聪明不是固定的。只要你相信聪明是靠努力可以弥补的，并且努力下去，你就会变聪明。</p>
<p>我们现在可以回到文章开头的问题了：觉得算法好难，<strong>自己不够聪明</strong>，要花好长时间才能理解一个算法，刷题效率也很低，半天能过一道题就不错了，我该怎么办？</p>
<p>对此，我的回答是：对不起，我没有更好的方法。并且，我坚信，不仅我没有，这个世界上根本不存在这样的一个方法。我经常使用反证法来阐述这个问题：假设这个世界存在一个简单、可行、快速、高效的学会算法的方法，那么，所有的人早就使用这个方法学习算法了，所有的人也早就成为算法大神了，算法也就不是什么让人头疼的事情了。可这是和现实不相符的。所以，这个方法不存在：）</p>
<p>以上证明不仅适用于算法学习，对各个领域的学习都适用。</p>
<p>但是，如果能给你一点安慰的话，我想实话告诉你：在我刚开始接触算法的时候，我也觉得算法好难，自己不够聪明，要花很长时间才能理解一个算法，刷题效率也特别低，别说半天一道题了，一个礼拜死磕一道题都是家常便饭。</p>
<p><strong>或许，你我都是天生不聪明的人。</strong></p>
<p>不过，好在，天生不聪明似乎并没有什么关系。因为，只要你相信聪明是靠努力可以弥补的，并且努力下去，你终将变得很“聪明”。甚至，你会超越这种“聪明”，理解一个很嘻哈又很深刻的道理：<strong>聪明不是什么大不了不起的事儿：）</strong></p>
<h3 id="选择和努力同样重要">选择和努力同样重要</h3>
<p>我用了这么长的文章，回答了一个问题。其实最后答案是一句废话：<strong>要努力</strong>。换句文绉绉的表示法，就是：<strong>万事无他，唯手熟尔</strong>。</p>
<p>当然，我也承认，只是努力，可能并不够。或者说，至少，还有改进的余地。人生是一个维度极其丰富的过程，用任何一个单一维度去解释它，都是极其幼稚可笑的。比如，我就认为，另外一个非常重要的维度，叫做“选择”。我们经常听到互联网上的一种声音：选择大于努力。对于这个观点怎么看？大家可以期待一下我的一篇文章，我会聊聊我对于“选择”的看法。</p>
<p>但是，在这篇文章里，作为计算机专业的同学，如果想学好算法，将来成为一个计算机科学领域的大神，并且你已经深刻地明白了努力就能更聪明，却不知如何选择从哪里开始努力的话... 咳咳咳，我建议大家从选择我在慕课网上的算法课程开始：）</p>
<h2 id="如果高效学习有什么秘诀的话那就都在这里了"><a href="https://mp.weixin.qq.com/s?__biz=MzU4NTIxODYwMQ==&amp;mid=2247483836&amp;idx=1&amp;sn=90854aa76507281403e4dd9cd434a12b&amp;chksm=fd8caefacafb27ec78f999fde4f1217c04c6e2ff28cf51fe511d8fa29d484d9281ff91de8c9c&amp;scene=21#wechat_redirect">如果高效学习有什么秘诀的话，那就都在这里了：）</a></h2>
<h3 id="不要完美主义">不要完美主义</h3>
<p>**学习不是要么0分，要么100分的。**80分是收获；60分是收获；20分也是收获。有收获最重要。但是因为着眼于自己的不完美，最终放弃了，那就是彻底的0分了。</p>
<p>仔细想，这种“完美主义害死人”的例子特别多。我看到过很多同学，其实是在学习的路上，被自己的“完美主义”逼得“放弃了”——由于学习中有一点没有做好，遭受到了一点点挫折，最终就放弃了整个学习计划。每个人都一定要接受自己的不完美。想开一点：我们都不是小升初考了满分，才能上初中的；也不是中考考了满分，才能读高中的；更不是高考考了满分，才能念大学的；将来也不会是大学所有科目都是满分，才能出来工作。<strong>不完美其实是常态</strong>，根本不会影响我们学习更多更深入的内容。<strong>但是在自学过程中，很多同学却要求自己在自己制定的每一步计划中都达到“完美”，才进行下一步。最终结果，通常都是“放弃”。</strong></p>
<p>可能有的同学会跳出来反驳我：学习当然要认真啊！在这里，我必须强调，我所说的“不要完美主义”，和“学习认真”是不冲突的。什么是“完美主义”，什么又是“囫囵吞枣”，这是一个“度”，每个人其实不一样。不要“完美主义”，不代表学习可以草率前行。每个人都必须要找到适合自己的学习节奏。<strong>我的经验是：在自己又因为自己的学习进度而沮丧的时候，问自己一句：是不是自己又犯“完美主义”的毛病了：）</strong></p>
<h3 id="不要过度依赖学习路径学习要冲着自己的目标去"><strong>不要过度依赖“学习路径”，学习要冲着自己的目标去。</strong></h3>
<p>比如，很多同学想学机器学习，大多数学习路径都会告诉你，机器学习需要数学基础。于是，很多同学就转而学习数学去了，非要先把数学学好再去学机器学习。可是发现数学怎么也学不好（在这里，可能完美主义的毛病又犯了），而机器学习却一点儿都没学。最终放弃了机器学习，非常可惜。其实，如果真正去接触机器学习，就会发现，至少在入门阶段，机器学习对数学的要求没有那么高。正因为如此，我一直建议：只要你在本科接触过高数，线数，概率这些科目的基础概念，想学机器学习，就去直接学习机器学习。学习过程中发现自己的数学不够用，再回头补数学。在这种情况下，数学学习得也更有目标性，其实效果更好。</p>
<p>类似这样的例子还有很多，很多同学想学习做ios app，就先去精通swift语言，或者想做android app，就先去精通java语言。在我看来大可不必。以我的经验，只要你有一门编译型语言基础，大概看一下这些语言的基础语法，就可以直接上手ios或者android app的开发了。先能做出一个最基本的app，在这个过程中，就会意识到语言特性的意义，再回头深入研究语言也不迟。此时还能结合真实的开发任务去理解语言特性，比没有上手app开发，抽象地理解语言特性，有意义的多。</p>
<p>再比如，我的《算法与数据结构》课程和《玩转算法面试》课程，在视频中都是使用C++进行编码的。虽然我一再强调对于算法的学习，语言不重要，但还是有很多同学表示，要先把C++学透，再回来把课程中的算法学好。这是完全没必要的。事实上，在我的这两门课程中，我看到的收获最大的同学，是那些能够把课程中的算法思想理解清楚，然后用自己熟悉的语言去实现的同学：）</p>
<p>依然是：不要“过度”学习路径依赖，什么叫“过度”，每个人的标准不一样。每个人都需要寻找自己的那个“度”。</p>
<h3 id="不要迷信权威的好教材"><strong>不要迷信权威的“好”教材。</strong></h3>
<p>不是说权威教材不好，而是每一本教材都有其预设的读者群，如果你不在这个预设的读者群的范畴里，教材再好也没用。最简单的例子：再好的高数教材，对于小学生来说，都是一堆废纸。</p>
<p>诚然，算法不容易，但是，一上来就抱着《算法导论》啃，实在是选择了一条完全没必要的，更难的，甚至可能是根本走不通的路。对于一个领域的学习，了解市面上有什么好的教材是必要的，单也不能迷信权威教材。<strong>每个人必须要去探索学习如何寻找适合自己的学习材料。</strong></p>
<h3 id="不要看不起薄薄的傻教材这些你看不起的学习材料可能是你入门某个领域的关键"><strong>不要看不起“薄薄”的“傻”教材，这些你看不起的学习材料，可能是你入门某个领域的关键。</strong></h3>
<p>在这里，关键字是够“薄”。因为“薄”的教材能让你以最快的速度看完，对整个学科有一个全盘的认识：这个领域是做什么的？解决什么问题了？整体解决问题的思路是怎样？解决问题的方法大致是怎样划分的？一些最基础的方法具体是怎样的。这些在初学阶段是至关重要！是让你全盘把握整个领域脉络的。虽然通过这么一本薄薄的教材，你的脉络把握肯定不够全面细致，但比没有强太多！</p>
<p>我看过不少同学，一上来学习《算法导论》，关于复杂度分析的笔记做了好几页，然后就放弃了，可是连什么是动态规划都不知道。这样完全没有对“算法”这个领域有全面的认识，甚至可以说根本没有学过“算法”！先用薄教材入门，再找“厚”教材，细细体会其中的细节，是我百试不爽的学习方法。</p>
<p>另外，在这里，我还要强调“入门教材”，很多教材虽然够“薄”，但不是“入门教材”。大家要注意。</p>
<h3 id="不要迷信单一教材"><strong>不要迷信单一教材。</strong></h3>
<p>在大多数情况下，学习不是一本固定教材可以搞定的。非要找到一本“最适合自己的”教材，然后就一头扎进去，其实是不科学的。</p>
<p>大多数同学喜欢仅仅扎进一本书里，一旦选定了自己的学习材料，就对其他材料充耳不闻，甚至是排斥的心理。这种做法，一方面又是“完美主义”的表现——非要把这本教材学透；另一方面，其实也是“犯懒”的表现，不愿意多翻翻，多看看，自己多比较比较，自己去寻找最适合自己的材料，一味地盲目相信所谓“大神”的推荐，殊不知，这些推荐，不一定是更适合自己的材料；更何况，还有很多大神，明明是靠不出名的“薄”教材入的门，但给别人做推荐的时候，就突然变成自己是算法奇才，自幼阅读《算法导论》而所成的神话了：）</p>
<h3 id="实践"><strong>实践！</strong></h3>
<p>前面说了很多和教材选择相关的话题，但**对于计算机领域的学习来说，教材的意义其实远远小于实践的意义。**如果仅仅是看学习材料就是学习的话，那么教学网站的视频后期处理人员就是水平最高的工程师了。因为每段视频，他们都需要看一遍。但是，很显然，仅仅是看视频，是无法学到知识的。**对于计算机领域的学习来说，真正动手实践去编程是异常重要的。怎么夸大其中的作用都不过分。**这就好比学游泳，必须下水去游泳；或者学开车，必须亲自上路。否则你说的再头头是道，一个小学生文化水平的人，只要他开过车，游过泳，都能在这两个领域瞬间秒杀你。</p>
<p>很多同学都说我的算法讲得好，其实，我一直认为，这其中的一个最简单的秘诀就是：我带领大家把大多数算法都非常细致的实现了一遍；或者对其中的应用进行了非常具体的实践。反观大多数高校教育，对于算法或者机器学习这种一定程度偏理论的学习，通常非常不强调实践。最终的结果是学习者只是接受了很多抽象的概念，但对其中具体的实现细节，却是云里雾里。我见过太多同学，都明白什么是O(n<sup>2)复杂度，什么是O(nlogn)的复杂度，却问我对于100万的数据规模，为什么自己的选择排序运行起来就没反应了。答案很简单：O(n</sup>2)的复杂度太慢了，100万的数据规模太大了，一般家用计算机转选择排序一时半会儿是转不完的。这些同学一定理解O(n^2)的算法比O(nlogn)的算法慢，却没有真正实践过，不知道这个差距到底是多少。</p>
<p>在我的课程中，经常遇到有些同学提出这样的问题：这个算法的某句话（或者某段逻辑），为什么要写成A的样子，而不是B的样子？这种问题其实很好，但我觉得解决方法也很简单，实际的去把算法改写成B的样子，实际的运行试试看，看会发生什么。如果发生了错误，仔细分析一下，为什么会有错误？如果没有错误，具体比较一下：A和B两种不同的写法，为什么都正确？又有什么区别？**真正的学习上的提高，就发生在这个过程中。**我当然可以告诉给同学们一个结果，但是自己亲自实践一遍，相比阅读我给出的一个答案，自己对其中问题理解的深刻程度，是完全不可比拟的。</p>
<h3 id="debug非常非常重要"><strong>debug非常非常重要。</strong></h3>
<p>我看到的另一类“经典”问题就是：老师，这个代码为什么错了，然后贴一大段代码。这种问题背后，依然是，透露着学习方法的不对劲：提问的同学懒得debug。**在计算机领域，debug近乎和实践是一个意思。**如果只是把材料上的代码“抄”一遍，这不叫实践，这叫抄代码。小学生也能做。但是“抄”一遍，不小心没抄对，发生了错误，然后自己一点一点调试，找到错误的根源，这叫真的实践。小学生不能做。（当然，自己理解了算法的逻辑，按照自己的理解，把算法写出来，才是终极目的：）</p>
<p>不过很多同学不喜欢debug，我当然理解。其实谁都不喜欢debug，但是，debug才是最重要的能力。**通常在一个领域里，你最不喜欢做的事情，就是这个领域的核心竞争力！**我见过的所有计算机领域的“高手”，不管是在哪个细分领域，都无一例外，是个debug好手。我经常告诉大家，在实际工作中，其实debug的时间要占你真正编程时间的70%。<strong>如果你做一个项目，根本不需要debug，要么是你的项目对你来说太简单了，要么是你根本没有接触到这个项目的核心。</strong></p>
<p>debug不仅仅是找到代码错误，解决错误的手段，其实更是一个重要的学习手段。通过debug，看看自己写的程序执行逻辑，哪里和自己设想的不一致？再回头看自己哪里想错了，或者想漏了，分析一下自己为什么想错了，或者想漏了，等等等等，依然是，进步就是发生在这个过程的。</p>
<p>在我的算法课程中，很多同学对递归想不明白，我的建议都是：用一个小数据量，一步步跟踪程序，看看程序到底是怎么运行的。通常这么做，1个小时的时间，就足以让你深刻理解递归程序的运转逻辑。可是，很多同学懒得花这1个小时的时间，最终的结果是，花了一个下午，对着代码生看，硬想，最终还是没有理解程序的运转逻辑。</p>
<h3 id="量变到质变"><strong>量变到质变。</strong></h3>
<p>还有很多同学，对于算法的一些问题，会问：老师，你是怎么想到用这样的方法的？对于这类问题，我的回答一般都是：你见的还不够多。</p>
<p>不知道是不是受高中阶段学习的影响，有一些同学特别执着于就着一个单一的问题，寻找其中的“解题路径”。当然，我不是说这是完全错误的，但也有一个“度”。我的经验是：与其把时间花在这里，不如去见更多问题。比如动态规划，是算法学习的一个难点，很多同学在学会了背包问题的解法之后，总是执着于去追寻：是怎么想到这种状态定义的方法的。可能是我个人水平有限，我无法清楚地解释是如何想到这种状态定义的方法的。但是我的经验告诉我：再去看，去实践100个动态规划相关的问题，然后回头看背包问题，你会发现这种状态定义的方式非常自然。**仅仅对着一个问题思考，很多时候都是死胡同。你见识的还不够多，就不足以帮助你总结出更加“普遍”的问题解决的规律。**当你见得足够多的时候，一切就都变得很自然，所谓的“量变到质变”。</p>
<p>不过，大多数同学在这个环节都会“犯懒”，企图通过一个问题就理解问题的本质，这其实和企图通过一本教材就精通一个领域的想法是一样的，是不现实的，不可能的。同时，这里又包含着学习过程中的“完美主义”的思想，遇到一个问题一定要把它想的无比透彻。但是我的经验告诉我：**大多数问题，其实都是需要“回头看”的。随着你对一个领域理解的越深入，回头再去看那些曾经的问题，都会产生新的视角，对于很多曾经想不明白的问题也豁然开朗。这也是“进步”的根源。**如果卡在一个问题上不前进，不给自己“回头看”的机会，甚至最后是放弃了，就什么也没有学会了。</p>
<p>所以，<strong>很多时候，你发现对一些问题“百思不得其解”，或许不是因为自己“笨”，而是因为“还不够努力”</strong>：）</p>
<h3 id="最后一定要相信时间的力量"><strong>最后，一定要相信时间的力量。</strong></h3>
<p>有一天，在我的一个算法课程群里，有个滴滴的后端大神发招聘，结果大家七嘴八舌的就议论开了，大致主题思想就是：自己什么时候能够成为滴滴的后端大神。这位滴滴的后端大神今年32岁；大多数议论的同学，其实连22岁都不到。我告诉他们，其实10年后，你们就是大神。</p>
<p>这其实很好理解，回想十年前，也就是12岁的你，和现在的你比较，是不是天壤之别？如果把你扔到一堆12岁的小朋友中间，22岁的你是不是就是个大神？同理，32岁的人，已经在业界摸爬滚打了那么多年，扔回到22岁的大学生中间，当然是大神：）</p>
<p>很多时候，所谓的“大神”并不神秘，仔细观察他们的经历，会发现时间有着不可磨灭的作用。只要你没有虚度时间，每天都在进步，通常结果都不会太差的。如果再加上一点点机遇，就是大神。</p>
<h2 id="想了解计算机的底层原理这些资源通俗易懂又有趣"><a href="https://mp.weixin.qq.com/s/h9mnGmIUoht7zRtDh6XD-g">想了解计算机的底层原理？这些资源通俗易懂又有趣</a></h2>
<p>大家可以关注一下波波老师的公众号和知识星球：是不是很酷</p>
<h2 id="总结">总结</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac工作环境搭建]]></title>
        <id>https://xinrong2019.github.io/post/mac-gong-zuo-huan-jing-da-jian/</id>
        <link href="https://xinrong2019.github.io/post/mac-gong-zuo-huan-jing-da-jian/">
        </link>
        <updated>2020-02-27T05:52:25.000Z</updated>
        <content type="html"><![CDATA[<h2 id="目录">目录</h2>
<p>[TOC]</p>
<h2 id="app软件">App软件</h2>
<ul>
<li>WPS</li>
<li>有道云笔记</li>
<li>CleanMyMac X</li>
<li>Visual studio code</li>
<li>uPic</li>
<li>Typora</li>
<li>Tencent Lemon</li>
<li>Snagit2020</li>
<li>ShadowsocksX-NG-R8</li>
<li>QQ</li>
<li>微信</li>
<li>钉钉</li>
<li>Polarr Photo Editor Pro</li>
<li>PDF Expert</li>
<li>Parallels DeskTop</li>
<li>Navicat Premium</li>
<li>Motrix</li>
<li>Mark Text</li>
<li>Little Snitch</li>
<li>Kap</li>
<li>IntelliJIDEA</li>
<li>IINA</li>
<li>Google Chrome</li>
<li>GoLand</li>
<li>Firefox</li>
<li>eZip</li>
<li>CotEditor</li>
<li>Clion</li>
<li>Araxis Merge</li>
<li>Android 文件传输</li>
<li>Kantu</li>
<li>Jietu</li>
<li>百度网盘</li>
</ul>
<h2 id="软件环境">软件环境</h2>
<ul>
<li>JDK</li>
<li>HomeBrew</li>
<li>Git</li>
<li>Gradle</li>
<li>Maven</li>
<li>GoLang</li>
</ul>
<h2 id="vim配置">vim配置</h2>
<pre><code class="language-bash">cd
vi .vimrc
##i进入编辑模式

# 显示行号
set number

# 检测文件类型
filetype on

# 开启语法高亮
syntax on

# 支持使用鼠标
set mouse=a

# 按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致。
set autoindent

# 按下 Tab 键时，Vim 显示的空格数
set tabstop=2

# 由于 Tab 键在不同的编辑器缩进不一致，该设置自动将 Tab 转为空格
set expandtab

# 是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示
set laststatus=2

# 在状态栏显示光标的当前位置（位于哪一行哪一列）
set ruler

##按esc键，退出编辑模式，输入:wq
</code></pre>
<h2 id="安装homebrew">安装HomeBrew</h2>
<p>常用命令</p>
<pre><code class="language-bash">brew list                 # 查看已经安装的包
brew update               # 更新Homebrew自身
brew doctor               # 诊断关于Homebrew的问题(Homebrew 有问题时请用它)
brew cleanup              # 清理老版本软件包或者无用的文件
brew show ${formula}      # 查看包信息
brew search ${formula}    # 按名称搜索
brew upgrade ${formula}   # 升级软件包
brew install ${formula}   # 按名称安装
brew uninstall ${formula} # 按名称卸载
brew pin/unpin ${formula} # 锁定或者解锁软件包版本，防止误升级
</code></pre>
<h2 id="terminal配置zsh配置">terminal配置(zsh配置)</h2>
<p><code>.bash_profile</code></p>
<pre><code class="language-bash">alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'
alias l='ls -alHh'
alias ..='cd ../'
alias ...='cd ../../'
export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles
</code></pre>
<p>Mac默认安装了zsh，下载<code>oh-my-zsh</code>简化配置，如果没安装，使用brew安装</p>
<pre><code class="language-bash"># 安装 zsh
brew install zsh

# 查看当前使用的 shell
echo $SHELL

# 切换 shell
chsh -s /bin/zsh

# 安装wget，安装oh-my-zsh用
brew install wget

# 安装oh-my-zsh
wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh

# 安装完后重启终端
</code></pre>
<p>zsh主题</p>
<pre><code class="language-bash">ZSH_THEME=&quot;af-magic&quot;
plugins=(
     git
    zsh-syntax-highlighting
    zsh-autosuggestions
    last-working-dir
    z
)
export GRADLE_USER_HOME=/Users/akm/.gradle
HIST_STAMPS=&quot;yyyy-mm-dd&quot;
</code></pre>
<p>在<code>.zshrc</code>文件中应用用户环境变量</p>
<pre><code class="language-bash"># .zshrc文件最后添加下面一行
source ~/.bash_profile
</code></pre>
<p>更新zsh配置</p>
<pre><code class="language-bash"># 更新配置
source ~/.zshrc
</code></pre>
<h2 id="upic安装配置">uPic安装配置</h2>
<h2 id="git安装和配置">Git安装和配置</h2>
<h2 id="finder配置">Finder配置</h2>
<ul>
<li>拷贝路径</li>
<li>在终端打开</li>
</ul>
<h2 id="mac其他">Mac其他</h2>
<ul>
<li>显示隐藏文件</li>
</ul>
<h2 id="maven">Maven</h2>
<p>settings.xml</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  
&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;
            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
            xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;
       &lt;pluginGroups&gt;
       &lt;/pluginGroups&gt;

       &lt;proxies&gt;
       &lt;/proxies&gt;     

       &lt;servers&gt;
       &lt;/servers&gt;

       &lt;mirrors&gt;
       &lt;mirror&gt;
      &lt;id&gt;aliyunmaven&lt;/id&gt;
      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
      &lt;name&gt;阿里云公共仓库&lt;/name&gt;
      &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;
     &lt;/mirror&gt;
      &lt;mirror&gt;
      &lt;id&gt;aliyunmaven&lt;/id&gt;
      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
      &lt;name&gt;阿里云谷歌仓库&lt;/name&gt;
      &lt;url&gt;https://maven.aliyun.com/repository/google&lt;/url&gt;
     &lt;/mirror&gt;
     &lt;mirror&gt;
      &lt;id&gt;aliyunmaven&lt;/id&gt;
      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
      &lt;name&gt;阿里云阿帕奇仓库&lt;/name&gt;
     &lt;url&gt;https://maven.aliyun.com/repository/apache-snapshots&lt;/url&gt;
     &lt;/mirror&gt;
     &lt;mirror&gt;
      &lt;id&gt;aliyunmaven&lt;/id&gt;
      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
      &lt;name&gt;阿里云spring仓库&lt;/name&gt;
      &lt;url&gt;https://maven.aliyun.com/repository/spring&lt;/url&gt;
     &lt;/mirror&gt;
     &lt;mirror&gt;
      &lt;id&gt;aliyunmaven&lt;/id&gt;
      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;
      &lt;name&gt;阿里云spring插件仓库&lt;/name&gt;
     &lt;url&gt;https://maven.aliyun.com/repository/spring-plugin&lt;/url&gt;
    &lt;/mirror&gt;
       &lt;/mirrors&gt;
&lt;profiles&gt;
       &lt;/profiles&gt;
       &lt;/settings&gt; 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Gradle高级应用]]></title>
        <id>https://xinrong2019.github.io/post/gao-ji-ying-yong/</id>
        <link href="https://xinrong2019.github.io/post/gao-ji-ying-yong/">
        </link>
        <updated>2020-02-01T12:50:42.000Z</updated>
        <content type="html"><![CDATA[<h2 id="构建脚本介绍">构建脚本介绍</h2>
<p>Gradle构建中的两个基本概念是项目（project）和任务（task），每个构建至少包含一个项目，项目中包含一个或多个任务。</p>
<p>在多项目构建中，一个项目可以依赖于其他项目；类似的，任务可以形成一个依赖关系图来确保他们的执行顺序。</p>
<h4 id="项目-任务关系">项目-任务关系</h4>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/AmQKRF_2020_2_1_10_2_34.png" alt="" loading="lazy"></figure>
<p>上图是一个项目任务关系图。</p>
<ol>
<li>Project1依赖Project2</li>
<li>Project1中，TaskA依赖TaskB和TaskC</li>
<li>Project2中，TaskF依赖TaskE，TaskE依赖TaskD</li>
</ol>
<h3 id="项目">项目</h3>
<p>一个项目代表一个正在构建的组件（比如一个jar文件），当构建启动后，Gradle会基于<code>build.gradle</code>实例化一个<code>org.gradle.api.Project</code>类，并且能够通过project变量使其隐式可用。</p>
<ul>
<li><code>group</code>、<code>name</code>、<code>version</code></li>
<li><code>apply</code>、<code>dependencies</code>、<code>repositories</code>、<code>task</code></li>
<li>属性的其他配置方式：<code>ext</code>、<code>gradle.properties</code></li>
</ul>
<h3 id="任务">任务</h3>
<p>任务对应<code>org.gradle.api.Task</code>。主要包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可以依赖于其他任务、动作序列和执行条件。</p>
<p>任务中的方法举例：</p>
<ul>
<li>dependsOn</li>
<li>doFirst、doLast</li>
</ul>
<h2 id="自定义任务">自定义任务</h2>
<h3 id="自动创建test目录结构">自动创建test目录结构</h3>
<h4 id="1在buildgradle文件中添加任务">1.在build.gradle文件中，添加任务</h4>
<pre><code class="language-groovy">def createDir = {
    path -&gt;
        File dir = new File(path)
        if(!dir.exists()){
            dir.mkdirs()
        }
}

task makeJavaDir(){
    def paths = ['src/test/java','src/test/resources']
    doFirst {
        paths.forEach(createDir)
    }
}
</code></pre>
<h4 id="2重新导入依赖">2.重新导入依赖</h4>
<p>不重新导入依赖，可能会看不到自定义任务</p>
<h4 id="3在tasks-other下执行makejavadir">3.在<code>Tasks-&gt;other</code>下执行makeJavaDir</h4>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/37C9t4_2020_2_1_10_49_46.png" style="zoom:50%;" />
<h3 id="自定义创建web目录">自定义创建web目录</h3>
<h4 id="1在buildgradle文件中添加任务-2">1.在build.gradle文件中，添加任务</h4>
<pre><code class="language-groovy">task makeWebDir(){
    dependsOn 'makeJavaDir'//依赖任务makeJavaDir
    def paths = ['src/main/webapp','src/test/webapp']
    doLast {
        paths.forEach(createDir)
    }
}
</code></pre>
<p>这里第二行我们使用dependsOn方法，依赖我们上一个任务makeJavaDir。这样在创建web目录时，可以把test目录也创建好。</p>
<h4 id="2重新导入依赖-2">2.重新导入依赖</h4>
<p>不重新导入依赖，可能会看不到自定义任务</p>
<h4 id="3在tasks-other下执行makewebdir">3.在<code>Tasks-&gt;other</code>下执行makeWebDir</h4>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/74RzQr_2020_2_1_10_57_59.png" style="zoom:50%;" />
<h2 id="构建的生命周期">构建的生命周期</h2>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/KHdsaR_2020_2_1_12_4_29.png" style="zoom:50%;" />
<p>理解构建的生命周期，生命周期通常会暴露扩展点，以供开发者使用，影响构建的行为，创建灵活的功能。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/OQTojI_2020_2_1_12_8_2.png" alt="" loading="lazy"></figure>
<h3 id="初始化">初始化</h3>
<p>初始化项目，决定有哪些项目参与到构建过程中</p>
<h3 id="配置">配置</h3>
<p>生成Task的执行关系和执行图</p>
<h3 id="执行">执行</h3>
<p>执行Task的动作</p>
<h2 id="依赖管理">依赖管理</h2>
<h3 id="概述">概述</h3>
<p>几乎所有的基于JVM的软件项目都需要依赖外部类库来重用现有的功能。自动化的依赖管理可以明确依赖的版本，可以解决因传递性依赖带来的版本冲突。</p>
<h3 id="工件坐标">工件坐标</h3>
<ul>
<li>group、name、version</li>
</ul>
<h3 id="常用仓库">常用仓库</h3>
<ul>
<li>mavenLocal/mavenCentral/jcenter</li>
<li>自定义maven仓库</li>
<li>文件仓库</li>
</ul>
<h3 id="依赖的传递性">依赖的传递性</h3>
<p>B依赖A，如果C依赖B，那么C依赖A</p>
<h3 id="自动化依赖管理">自动化依赖管理</h3>
<p>首次使用jar，会从远程仓库下载到本地仓库；</p>
<p>如果多次使用相同的jar，会缓存到本地缓存</p>
<h3 id="依赖阶段配置">依赖阶段配置</h3>
<ul>
<li>compile、runtime</li>
<li>testCompile、testRuntime</li>
</ul>
<h3 id="依赖阶段关系">依赖阶段关系</h3>
<h3 id="添加logback编译时依赖">添加logback编译时依赖</h3>
<pre><code class="language-groovy">compile 'ch.qos.logback:logback-classic:1.2.1'
</code></pre>
<h2 id="解决版本冲突">解决版本冲突</h2>
<h3 id="版本冲突例子">版本冲突例子</h3>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/dkmvOq_2020_2_1_14_1_56.png" alt="" loading="lazy"></figure>
<h3 id="解决冲突">解决冲突</h3>
<ul>
<li>查看依赖报告</li>
</ul>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/UWAqfx_2020_2_1_14_11_6.png" style="zoom:50%;" />
<ul>
<li>排除传递性依赖</li>
<li>强制指定一个版本</li>
</ul>
<p>注意：gradle会默认解决版本冲突，使用最高版本的冲突依赖。</p>
<ul>
<li>修改默认解决策略</li>
</ul>
<pre><code class="language-groovy">configuration.all{
  resolutionStrategy{
    failOnVersionConflict()
  }
}
</code></pre>
<p>让版本冲突出现时报错，让我们知道。</p>
<h4 id="排除传递性依赖">排除传递性依赖</h4>
<pre><code class="language-groovy">compile('org.hibernate:hibernate-core:3.6.3.final'){
  exclude group:&quot;org.slf4j&quot;,module:&quot;slf4j-api&quot;
  //transitive = false
}
</code></pre>
<p>其中module，就是name。</p>
<h4 id="强制指定一个版本">强制指定一个版本</h4>
<pre><code class="language-groovy">configuration.all{
  resolutionStrategy{
    force 'org.slf4j:slf4j-api:1.7.24'
  }
}
</code></pre>
<h2 id="多项目构建介绍">多项目构建介绍</h2>
<h3 id="项目模块化">项目模块化</h3>
<p>在企业项目中，包层次和类关系比较复杂，把代码拆分成模块通常是最佳实践，这需要你清晰的划分功能的边界，比如把业务逻辑和数据持久化拆分开来。项目符合高内聚低耦合时，模块化就变得很容易，这是一条非常好的软件开发实践。</p>
<h3 id="todo模块依赖关系">TODO模块依赖关系</h3>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/gZTQAv_2020_2_1_14_46_12.png" style="zoom:50%;" />
<h3 id="配置要求">配置要求</h3>
<ul>
<li>所有项目应用Java插件</li>
<li>web子项目打包成war</li>
<li>所有项目添加logback日志功能</li>
<li>统一配置公共属性</li>
</ul>
<h3 id="项目拆分gradle多项目构建">项目拆分，gradle多项目构建</h3>
<h4 id="1新建两个模块都是gradle项目">1.新建两个模块，都是gradle项目</h4>
<h5 id="11-右键点击根目录todonew-module">1.1 右键点击根目录todo，<code>new-&gt;Module</code></h5>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/EOKycA_2020_2_1_17_59_9.png" alt="" loading="lazy"></figure>
<h5 id="12-新建gradle模块点击next">1.2 新建gradle模块，点击next</h5>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/K7u7Gl_2020_2_1_18_1_18.png" style="zoom:50%;" />
<h5 id="13-填入模块名然后next再next">1.3 填入模块名，然后next，再next</h5>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/ERaQT2_2020_2_1_18_2_21.png" style="zoom:50%;" />
<h5 id="14-按照上面三步建立model-repository和web模块">1.4 按照上面三步建立<code>model</code>、<code>repository</code>和<code>web</code>模块</h5>
<h5 id="15-根目录下的settinggradle文件中会有gradle管理的项目描述">1.5 根目录下的<code>setting.gradle</code>文件中会有gradle管理的项目描述</h5>
<pre><code class="language-groovy">rootProject.name = 'todo'
include 'model'
include 'repository'
include 'web'
</code></pre>
<h5 id="16添加模块依赖">1.6添加模块依赖</h5>
<p>我们的项目repository模块依赖model模块，web模块依赖repository模块。</p>
<p>所以需要在repository模块中添加model模块的依赖，在web模块中添加repository模块依赖。</p>
<pre><code class="language-groovy">dependencies {
    compile project(&quot;:model&quot;)
    testCompile group: 'junit', name: 'junit', version: '4.12'
}
</code></pre>
<pre><code class="language-groovy">dependencies {
    compile project(&quot;:repository&quot;)
    testCompile group: 'junit', name: 'junit', version: '4.12'
}
</code></pre>
<h2 id="多项目构建实战">多项目构建实战</h2>
<h3 id="1所有项目中应用java插件">1.所有项目中应用Java插件</h3>
<p>将子模块的java插件配置都删除，在根项目中使用allprojects方法应用</p>
<pre><code class="language-groovy">group 'com.kim.gradle'
version '1.0-SNAPSHOT'

allprojects {
    apply plugin:'java'
    sourceCompatibility = 1.8
}

repositories {
    mavenCentral()
}
//省略其他配置
</code></pre>
<h3 id="2web子项目打包成war">2.web子项目打包成war</h3>
<p>个性化需求，给web子模块应用war插件</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/AmW1hy_2020_2_1_18_24_36.png" style="zoom:50%;" />
<h3 id="3所有项目添加logback日志功能包括junit">3.所有项目添加logback日志功能，包括Junit</h3>
<pre><code class="language-groovy">allprojects {
    apply plugin:'java'
    sourceCompatibility = 1.8
}
subprojects {
    repositories {
        mavenCentral()
    }
    dependencies {
        compile 'ch.qos.logback:logback-classic:1.2.1'
        testCompile 'junit:junit:4.12'
    }
}
</code></pre>
<p>这里用subprojects可以达到同样的效果</p>
<h3 id="4统一配置group和version">4.统一配置group和version</h3>
<p>在根目录下新建<code>gradle.properties</code>文件，加入这两个属性。</p>
<pre><code class="language-properties">group=com.kim.gradle
version=1.0-SNAPSHOT
</code></pre>
<p>同时，子模块中删除这两个属性。</p>
<h3 id="5执行root项目的clean任务">5.执行root项目的clean任务</h3>
<p>执行root项目的clean任务，观察执行顺序。</p>
<pre><code class="language-groovy">&gt; Task :clean
&gt; Task :model:clean UP-TO-DATE
&gt; Task :repository:clean UP-TO-DATE
&gt; Task :web:clean
</code></pre>
<h2 id="自动化测试">自动化测试</h2>
<h3 id="1测试配置">1.测试配置</h3>
<pre><code class="language-groovy">dependencies {
    testCompile 'junit:junit:4.12'
}
</code></pre>
<h3 id="2测试发现">2.测试发现</h3>
<p>gradle是如何发现哪些类或方法是测试类的呢</p>
<ul>
<li>任何继承自junit.framework.TestCase或groovy.util.GroovyTestCase的类</li>
<li>任何被@RunWith注解的类</li>
<li>任何至少包含一个被@Test注解的类</li>
</ul>
<h2 id="发布">发布</h2>
<h3 id="配置发布插件">配置发布插件</h3>
<pre><code class="language-groovy">allprojects {
    apply plugin:'java'
    sourceCompatibility = 1.8

    apply plugin: 'maven-publish'

    publishing {
        publications {
            myPublish(MavenPublication){
                from components.java
            }
        }
        repositories {
            maven {
                name &quot;myRepo&quot;
                url &quot;&quot;
            }
        }
    }
}
</code></pre>
<h3 id="发布到本地仓库">发布到本地仓库</h3>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/uWkXKt_2020_2_1_19_20_25.png" style="zoom:50%;" />
<h3 id="发布到公司私服">发布到公司私服</h3>
<p>在发布插件配置中配置公司私服的url，然后执行publish这个任务</p>
<p><a href="https://github.com/SixGodFlowerDewWater1029/gradle">项目源码</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[第一个Gradle项目]]></title>
        <id>https://xinrong2019.github.io/post/di-yi-ge-gradle-xiang-mu/</id>
        <link href="https://xinrong2019.github.io/post/di-yi-ge-gradle-xiang-mu/">
        </link>
        <updated>2020-02-01T12:49:33.000Z</updated>
        <content type="html"><![CDATA[<h3 id="示例介绍">示例介绍</h3>
<ul>
<li>TODO应用程序，只实现添加待办事项</li>
<li>Java应用程序版</li>
<li>Web版</li>
</ul>
<h2 id="java应用程序版">Java应用程序版</h2>
<h3 id="启动类">启动类</h3>
<pre><code class="language-java">package com.kim.gradle.todo;

import java.util.Scanner;

public class App {
    public static void main(String[] args) {
        int i = 0;
        Scanner scanner = new Scanner(System.in);
        while (++i &gt; 0){
            System.out.println(i + &quot;. please input todo item name&quot;);
            ToDoItem item = new ToDoItem(scanner.nextLine());
            System.out.println(item);
        }
    }
}

</code></pre>
<h3 id="todoitem">ToDoItem</h3>
<pre><code class="language-java">package com.kim.gradle.todo;

public class ToDoItem {
    private String name;
    private boolean hasDone;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isHasDone() {
        return hasDone;
    }

    public void setHasDone(boolean hasDone) {
        this.hasDone = hasDone;
    }

    public ToDoItem(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return &quot;ToDoItem{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, hasDone=&quot; + hasDone +
                '}';
    }
}

</code></pre>
<h3 id="打jar包">打jar包</h3>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/eTOKvN_2020_1_31_20_37_44.png" style="zoom:50%;" />
<h3 id="控制台中运行程序">控制台中运行程序</h3>
<p><code>java -classpath build/libs/todo-1.0-SNAPSHOT.jar com.kim.gradle.todo.App</code></p>
<pre><code>1. please input todo item name
kim
ToDoItem{name='kim', hasDone=false}
2. please input todo item name
</code></pre>
<h2 id="web版">Web版</h2>
<h3 id="添加war插件">添加war插件</h3>
<p>在build.gradle文件中添加war插件</p>
<pre><code class="language-groovy">plugins {
    id 'java'
    id 'war'//添加的内容
}

//apply plugin:'java'
//apply plugin:'war'

group 'com.kim.gradle'
version '1.0-SNAPSHOT'

sourceCompatibility = 1.8

repositories {
    mavenCentral()
}

dependencies {
    testCompile group: 'junit', name: 'junit', version: '4.12'
}
</code></pre>
<p>plugins方法也可以由apply方法替换</p>
<h3 id="打war包">打war包</h3>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/8VqsEx_2020_1_31_20_58_8.png" style="zoom:50%;" />
<p>打包后，在项目根目录/build/libs下会生成war包，将war复制到一个servlet容器中，比如tomcat的webapp目录下，运行即可。</p>
]]></content>
    </entry>
</feed>