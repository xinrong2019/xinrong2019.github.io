<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta HTTP-EQUIV="pragma" CONTENT="no-cache"> 
<meta HTTP-EQUIV="Cache-Control" CONTENT="no-cache, must-revalidate"> 
<meta HTTP-EQUIV="expires" CONTENT="0"> 
<title>分布式基础理论认知 | Eucaly</title>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.css">

<link rel="stylesheet" href="https://xinrong2019.github.io//styles/main.css">
<script type="text/javascript">
function getCSS()
{
        datetoday = new Date();
        timenow=datetoday.getTime();
        datetoday.setTime(timenow);
        thehour = datetoday.getHours();

            display = "https://xinrong2019.github.io//media/css/night.css";

            display = "https://xinrong2019.github.io//media/css/night.css";   
      
            display = "https://xinrong2019.github.io//media/css/day.css";

            display = "https://xinrong2019.github.io//media/css/day.css";
      

var css = '<';
        css+='link rel="stylesheet" href='+display+' \/';
        css+='>';
        document.write(css);
}
</script>
<link href="https://fonts.googleapis.com/css?family=Dancing+Script|Noto+Sans+SC:300|Montserrat&display=swap" rel="stylesheet">
<link href="https://at.alicdn.com/t/font_1306644_jwtuc2zzbrd.css" rel="stylesheet" />
<link href="https://at.alicdn.com/t/font_1651848_tf0hnpbyjfj.css" rel="stylesheet" />
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<script type='text/javascript' src='https://xinrong2019.github.io//media/scripts/script.js'></script>
<link href="https://cdn.bootcss.com/animate.css/3.5.2/animate.min.css" rel="stylesheet" />
  <script src="https://cdn.bootcss.com/wow/1.1.2/wow.min.js"></script>
  <script src="https://cdn.bootcss.com/highlight.js/9.15.8/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <script>wow=new WOW({boxClass:'wow',animateClass:'animated',offset:0,mobile:true,live:true});wow.init();</script>

<script type="text/javascript">
window.onload=getCSS();
</script>


</head>

<body class="post-template-default single single-post postid-70 single-format-standard">
	<div id="wrapper">
				<header id="header" class="site-header" >
			<div class="site-branding">
				<h1 class="site-title">
					<div class="post-title-name">
						<a href="https://xinrong2019.github.io/" rel="home">分布式基础理论认知</a>
					</div>
				</h1>
				<h2 class="site-description">Time waits for no one.</h2>
			</div>
			<nav id="nav-wrapper">
				<div class="container">
					<div class="nav-toggle">
						<div class="bars">
							<div class="bar"></div>
							<div class="bar"></div>
							<div class="bar"></div>
						</div>
					</div>
					<div class="clear"></div>
					<ul id="" class="dove">
						

						<li>

							<a href="/"> 首页</a></li>

						

						<li>

							<a href="/archives"> 归档</a></li>

						

						<li>

							<a href="/tags"> 标签</a></li>

						

						<li>

							<a href="/friends"> 友链</a></li>

						

						<li>

							<a href="/post/mysql"> MySQL</a></li>

						

						<li>

							<a href="/post/dubbo"> Dubbo</a></li>

						

						<li>

							<a href="/post/mq"> MQ</a></li>

						

						<li>

							<a href="/post/spring"> Spring</a></li>

						

						<li>

							<a href="/post/about"> 关于</a></li>

						

					</ul>
					</li>

					</ul>
				</div>
			</nav>

			<div class="jingge">
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
			</div>
			<form id="gridea-search-form" data-update="1588033196802" action="/search/index.html">
				<div class="search-box">
					<input class="search-txt" name="q" placeholder="Type to search" />
					<a class="search-btn">
						<i class="iconfont icon-search1" action="/search/index.html"></i>
					</a>
				</div>
			</form>
		</header>
		<div id="content" class="container">
			<div class="row">
				<div class="col-md-8 site-main">
					<article id="post-70"
						class="post-70 post type-post status-publish format-standard hentry category-5 tag-10 tag-9 tag-11">
						<div class="entry-content">
							<div class="entry-meta">
								<div class="entry-info">
									<time>
										2020-04-28
									</time>
									<span>
										26 min read
									</span>
								</div>
							</div>
							<div class="wow slideInLeft entry-summary song">
								<h1 id="分布式">分布式</h1>
<h2 id="toc">TOC</h2>
<p>[TOC]</p>
<h2 id="分布式系统定义及面临的问题">分布式系统定义及面临的问题</h2>
<p>分布式系统定义为：</p>
<blockquote>
<p>分布式系统是一个硬件或软件组件分布式在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p>
</blockquote>
<h3 id="分布式环境的各种问题">分布式环境的各种问题</h3>
<h4 id="通信异常">通信异常</h4>
<h4 id="网络分区">网络分区</h4>
<h4 id="三态">三态</h4>
<p>分布式系统每一个请求与响应存在特有的“三态”概念，即成功、失败和超时。</p>
<h4 id="节点故障">节点故障</h4>
<h2 id="分布式理论一致性概念">分布式理论：一致性概念</h2>
<p>不同场景对分布式一致性的需求是不同的。</p>
<p>火车站售票系统，要求数据是实时一致；</p>
<p>转账系统要求最终一致，但是要正确；</p>
<p>网购系统要求最终一致，中间会存在不一致的状态，但是最终也会是一致的。</p>
<h3 id="分布式一致性的提出">分布式一致性的提出</h3>
<p>数据库之间复制的延时。</p>
<p>为什么要数据复制：</p>
<ol>
<li>增加系统可用性，防止单点故障导致系统不可用</li>
<li>可以通过负载均衡，提高系统整体性能</li>
</ol>
<p>数据一致性，是指对一个副本数据进行更新的时候，必须确保也能更新其他的副本，否则不同副本之间的数据将不一致。</p>
<p>一致性级别：</p>
<ol>
<li>
<p>强一致性</p>
</li>
<li>
<p>弱一致性（尽可能保证一定时间内达到数据一致）</p>
</li>
<li>
<p>最终一致性（一定保证一定时间内达到数据一致）</p>
</li>
</ol>
<h3 id="分布式事务">分布式事务</h3>
<p>是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点上，通常一个分布式事务会涉及到多个数据源或业务系统的操作。</p>
<h3 id="分布式理论-cap定理">分布式理论-CAP定理</h3>
<h4 id="什么是cap定理">什么是CAP定理</h4>
<p>CAP理论告诉我们，一个分布式系统，不可能同时满足一致性（C:Consistency），可用性（A:Availability）和分区容错性（P:Partition tolerance）这三个基本需求，最多只能同时满足其中两个。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419215151575.png" alt="image-20200419215151575" loading="lazy"></figure>
<p>对于分布式系统而言，分区容错性可以说是一个基本的要求，因此架构师往往需要把精力花在如何根据业务特点在C（一致性）和A（可用性）之间寻求平衡。</p>
<h4 id="能不能解决3选2的问题">能不能解决3选2的问题</h4>
<p>需要思考分区是不是百分之百出现呢？</p>
<p>如果不出现，那么就能够同时满足CAP。</p>
<p>如果出现了分区，可以根据策略进行调整。比如C不必使用那么强的一致性，可以先将数据存起来，稍后更新，实现所谓的“最终一致性”。</p>
<p>基于这个思路，也引出了第二个理论Base理论。</p>
<h3 id="分布式理论-base理论">分布式理论-BASE理论</h3>
<h4 id="什么是base理论">什么是BASE理论</h4>
<p>全称：Basically Available(基本可用)，Soft state(软状态)，和Eventually consistent(最终一致)三个短语的缩写，来自ebay的架构师提出。</p>
<h4 id="base理论和cap理论的关系">Base理论和CAP理论的关系</h4>
<p>Base理论是对CAP中一致性和可用性权衡的结果，其来源于大型互联网分布式实践的总结，是基于CAP定理逐步演化而来的。</p>
<h4 id="basically-available基本可用">Basically Available(基本可用)</h4>
<p>分布式系统在出现不可预知的故障时，允许损失部分可用性。而不是完全不可用。具体举两个例子：</p>
<ul>
<li>响应时间上的损失：正常情况下，一个在线搜索引擎要在0.5秒内返回用户相应结果，但由于出现故障，查询结果的响应时间增加到了1-2秒</li>
<li>功能上的损失：对于电商网站，在大促时，由于消费者的购物行为激增，为了保护系统的稳定性（或者保证一致性），部分消费者可能会被引导到一个降级页面。比如如下页面<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419220228459.png" alt="image-20200419220228459" style="zoom:50%;" /></li>
</ul>
<h4 id="soft-state软状态">Soft state(软状态)</h4>
<p>什么是软状态？相对于一致性，要求多个节点的数据副本都是一致的，这是一种“硬状态”。</p>
<p>软状态是指：允许系统中的数据存在中间状态，并认为该状态不影响系统整体可用性，即允许系统在多个不同节点的数据副本之间进行数据同步的过程中存在延迟。</p>
<h4 id="eventually-consistent最终一致">Eventually consistent(最终一致)</h4>
<p>强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
<p>在实际工程实践中，最终一致性存在以下五类主要变种：</p>
<ol>
<li>
<p>因果一致性（Causal consistency）</p>
</li>
<li>
<p>读己之所写（Read your writes）</p>
</li>
<li>
<p>会话一致性（Session consistency）</p>
</li>
<li>
<p>单调读一致性（Monotonic read consistency）</p>
</li>
<li>
<p>单调写一致性（Monotonic write consistency）</p>
</li>
</ol>
<p>实际系统实践中，可以将其中若干个变种互相结合起来，以构建一个具有最终一致性的分布式系统。</p>
<p>总结：BASE理论面向的是大型高可用可扩展的分布式系统，通过牺牲强一致性来获得可用性，并允许数据在一段时间是不一致的，但最终要保证数据一致。</p>
<h3 id="分布式理论-一致性协议2pc">分布式理论-一致性协议2PC</h3>
<p>背景：为了使系统尽量能够达到CAP，于是有了BASE协议，而BASE协议是在可用性和一致性之间做的取舍和妥协。</p>
<p>我们在对分布式系统进行架构设计的时候，对可用性和一致性反复权衡的过程中，涌现了一些经典的算法和协议，最著名的几种就是二阶段提交协议，三阶段提交协议，Paxos算法等。</p>
<h4 id="什么是2pc">什么是2PC</h4>
<p>协调者：统一调度所有分布式节点的执行逻辑。负责调度参与者的行为，并最终决定这些参与者是否要把事务真正进行提交。</p>
<p>参与者：被调度的节点</p>
<p>二阶段提交就是把事务的提交过程分成了两个阶段来进行处理。流程如下：</p>
<h5 id="阶段一提交事务请求">阶段一：提交事务请求</h5>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419222047888.png" alt="image-20200419222047888" style="zoom:33%;" />
<ol>
<li>事务询问</li>
</ol>
<p>协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。</p>
<ol start="2">
<li>执行事务</li>
</ol>
<p>各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中</p>
<p>（Redo用来保证事务的原子性和持久性，Undo能保证事务的一致性，两者也是系统恢复的基础前提）</p>
<ol start="3">
<li>各参与者向协调者反馈事务询问的响应</li>
</ol>
<p>如果参与者成功执行了事务操作，那么久反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务操作，就反悔No给协调者，表示事务不可以执行。</p>
<p>又称为投票阶段，即各参与者投票表明是否要继续执行接下来的事务提交操作。</p>
<h5 id="阶段二执行事务提交">阶段二：执行事务提交</h5>
<p>根据阶段一的结果决定是否可以进行事务提交操作，正常情况下，包含两种操作可能：提交事务，中断事务。</p>
<h6 id="提交事务过程如下">提交事务过程如下：</h6>
<p>假如阶段一所有参与者反馈都是Yes，那么就会执行事务的提交</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419222748654.png" alt="image-20200419222748654" style="zoom:33%;" />
<ol>
<li>发送提交请求</li>
</ol>
<p>协调者向所有参与者发送commit请求</p>
<ol start="2">
<li>事务提交</li>
</ol>
<p>参与者收到commit请求后，会正式执行事务提交操作，并在完成提价之后释放整个事务执行期间占用的事务资源。</p>
<ol start="3">
<li>反馈事务提交结果</li>
</ol>
<p>参与者在完成事务提交之后，向协调者发送Ack信息</p>
<ol start="4">
<li>完成事务</li>
</ol>
<p>协调者接收到所有参与者反馈的Ack信息后，完成事务。</p>
<h6 id="中断事务步骤如下">中断事务步骤如下：</h6>
<p>假如任何一个参与者向协调者反馈了No响应，或者在等待超时后，协调者尚未接收到所有参与者的反馈响应，那么就会中断事务。</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419223154284.png" alt="image-20200419223154284" style="zoom:33%;" />
<ol>
<li>发送回滚请求</li>
</ol>
<p>协调者向所有参与者发送Rollback请求</p>
<ol start="2">
<li>事务回滚</li>
</ol>
<p>参与者接收到Rollback请求后，会利用其在阶段一记录的Undo信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源</p>
<ol start="3">
<li>反馈事务回滚的结果</li>
</ol>
<p>参与者在完成事务回滚后，向协调者发送Ack信息</p>
<ol start="4">
<li>中断事务</li>
</ol>
<p>协调者接收到所有的参与者反馈的Ack信息后，完成事务中断。</p>
<p>2PC主要做了两个事情：投票，执行。</p>
<p>将事务的处理过程分为了投票和执行两个阶段，核心是对每个事务都采用先尝试后提交的处理方式，从而保证其原子性和一致性，因此可以将二阶段提交看成一个强一致性的算法。</p>
<h4 id="2pc优缺点">2PC优缺点</h4>
<p>优点：</p>
<p>原理简单，实现方便</p>
<p>缺点：</p>
<p>同步阻塞，单点问题，数据不一致，过于保守</p>
<ol>
<li>同步阻塞</li>
</ol>
<p>各个参与者在等待其他参与者响应的过程中，无法进行其他操作。限制了分布式系统的性能。然而分布式系统就是为了提高系统整体的性能。</p>
<ol start="2">
<li>单点问题</li>
</ol>
<p>协调者单点问题</p>
<ol start="3">
<li>数据不一致</li>
</ol>
<p>协调者向所有参与者发送commit请求后，发生了局部网络异常或者协调者在尚未发送完所有commit请求之前自身发生了崩溃，最终导致只有部分参与者收到了commit请求。将导致严重的数据不一致问题。</p>
<ol start="4">
<li>过于保守</li>
</ol>
<p>协调者通过超时机制判断是否需要中断事务，这种策略过于保守。</p>
<p>二阶段没有设计较为完善的容错机制，任意一个节点失败都会导致整个事务的失败。</p>
<h3 id="分布式理论-一致性协议3pc">分布式理论-一致性协议3PC</h3>
<p>背景：为了弥补阶段二提交的缺点</p>
<h4 id="什么是三阶段提交">什么是三阶段提交</h4>
<p>将2PC的提交事务请求过程一分为二，共形成了由CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419224754436.png" alt="image-20200419224754436" loading="lazy"></figure>
<h4 id="阶段一cancommit">阶段一：CanCommit</h4>
<ol>
<li>事务询问</li>
</ol>
<p>协调者向所有参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应</p>
<ol start="2">
<li>各参与者向协调者反馈事务询问的响应</li>
</ol>
<p>参与者在接收到来自协调者的包含了事务内容的canCommit请求后，正常情况下，如果自身认为可以顺利执行事务，则反馈Yes响应，并进入预备状态，否则反馈No响应</p>
<h4 id="阶段二precommit">阶段二：PreCommit</h4>
<p>协调者在得到所有参与者的响应之后，根据结果有两种执行操作的情况：执行事务预提交，或者中断事务</p>
<p>假如所有参与者反馈都是Yes，那么就会执行事务预提交</p>
<p>执行事务预提交分为三个步骤：</p>
<ol>
<li>发送预提交请求</li>
</ol>
<p>协调者向所有参与者节点发送preCommit请求，并进入prepared阶段。</p>
<ol start="2">
<li>事务预提交</li>
</ol>
<p>参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。</p>
<ol start="3">
<li>各参与者向协调者反馈事务执行的结果</li>
</ol>
<p>若参与者成功执行了事务操作，那么反馈Ack，同时等待最终的指令：提交或终止</p>
<p>若任一参与者反馈了No响应，或者在等待超时后，协调者尚未接收到所有参与者反馈，则中断事务</p>
<p>中断事务也分为两个阶段：</p>
<ol>
<li>
<p>发送中断请求</p>
</li>
<li>
<p>中断事务</p>
</li>
</ol>
<h4 id="阶段三docommit">阶段三：doCommit</h4>
<p>这个阶段，做真正的事务提交完成回滚</p>
<p>执行事务提交：</p>
<ol>
<li>发送提交请求</li>
<li>事务提交</li>
<li>反馈提交结果</li>
<li>完成事务</li>
</ol>
<p>中断事务：</p>
<ol>
<li>
<p>发送中断请求：协调者向所有参与者节点发送abort请求。</p>
</li>
<li>
<p>事务回滚</p>
</li>
<li>
<p>反馈事务回滚结果</p>
</li>
<li>
<p>中断事务</p>
</li>
</ol>
<p>一旦进入阶段三，可能会出现两种故障：</p>
<ol>
<li>协调者出现问题</li>
<li>协调者和参与者之间的网络故障</li>
</ol>
<p>如果出现任意一种情况，最终都会导致参与者无法收到doCommit请求或者abort请求，针对这种情况，<strong>参与者都会在等待超时之后，继续进行事务提交。</strong></p>
<h4 id="3pc优缺点">3PC优缺点</h4>
<p>优点</p>
<p>最大的优点是降低了参与者的阻塞范围（第一阶段不阻塞），其次能够在单点故障后继续达成一致（2PC在提交阶段会出现此问题，3PC会根据<strong>协调者的状态</strong>进行回滚或者提交）。</p>
<p>缺点</p>
<p>如果参与者收到了preCommit消息后，出现了网络分区，此时协调者所在节点和参与者所在节点无法进行网络通信，那么参与者等待超时后，会进行事务提交，这必然会出现分布式<strong>数据不一致</strong>的问题。</p>
<p>2PC和对比3PC</p>
<ol>
<li>
<p>对于协调者和参与者都设置了超时机制（而2PC只有协调者有超时机制，即如果在一定时间内，没有收到参与者的消息则默认失败）。</p>
</li>
<li>
<p>在2PC准备阶段和提交阶段之间，插入了预提交阶段，是一个缓冲，保证了最后提交阶段之前各个参与节点的状态是一致的。</p>
</li>
</ol>
<h3 id="分布式理论一致性算法paxos">分布式理论：一致性算法Paxos</h3>
<h4 id="什么是paxos算法">什么是Paxos算法</h4>
<p>一种基于消息传递且具有高度容错特性的一致性算法。主要用来解决分布式系统中，如何就某个值达成一致的算法。</p>
<p>Google Chubby</p>
<p>OceanBase</p>
<h4 id="paxos解决了什么问题">Paxos解决了什么问题</h4>
<p>解决了一致性问题</p>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419231712855.png" alt="image-20200419231712855" loading="lazy"></figure>
<p>在分布式系统中，发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序、网络分区）等情况。可以快速且准确的在集群内对某个数据的值达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性。</p>
<p>假如，一个集群环境中，要求所有机器上的状态是一致的，其中有两台机器想修改某一个状态，机器A想把状态修改为A，机器B想把状态修改为B，那么到底听谁的？</p>
<p>进一步思考，可以引入协调者，谁先到，听谁的。</p>
<p>但是协调者宕机了呢？</p>
<p>所以需要对协调者也做备份也要做集群，这时候，问题来了，这么多协调者，听谁的呢？</p>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419232217900.png" alt="image-20200419232217900" loading="lazy"></figure>
<p>Paxos算法就是为了解决这个问题而生的</p>
<h4 id="paxos相关概念">Paxos相关概念</h4>
<p>提案（Proposal）：最终要达成一致的value就在提案里。包括提案编号（Proposal ID）和提议的值（Value）</p>
<h5 id="三种角色">三种角色：</h5>
<ul>
<li>Proposer:提案发起者</li>
<li>Acceptor:决策者，可以批准提案，接受提案</li>
<li>Leaners:最终决策的学习者</li>
</ul>
<p>如果某个提案被选定，那么该提案的value就被选定了。</p>
<p>具体的实现中，一个进程可能同时充当多种角色。可能即是Proposer又是Acceptor又是Leaner。</p>
<h5 id="怎么理解对某个数据的值达成一致">怎么理解“对某个数据的值达成一致”？</h5>
<p>指的是Proposer、Acceptor、Leaner都认为同一个value被选定。</p>
<h5 id="那么proposer-acceptor-leaner分别在什么情况下才能认为某个value被选定呢">那么Proposer、Acceptor、Leaner分别在什么情况下才能认为某个value被选定呢？</h5>
<figure data-type="image" tabindex="5"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419232931076.png" alt="image-20200419232931076" loading="lazy"></figure>
<h4 id="问题描述">问题描述</h4>
<p>假设有一组可以提出提案的进程集合，那么对于一个一致性算法需要保证以下几点：</p>
<ul>
<li>在这些被提出的提案中，只有一个提案会被选定</li>
<li>如果没有提案被提出，就不应该有被选定的提案</li>
<li>当一个提案被选定后，那么所有进程都应该能学习（learn）到这个被选定的value</li>
</ul>
<h4 id="推导过程">推导过程</h4>
<h5 id="最简单的方案只有一个acceptor">最简单的方案，只有一个Acceptor。</h5>
<figure data-type="image" tabindex="6"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419233349101.png" alt="image-20200419233349101" loading="lazy"></figure>
<h5 id="多个acceptor">多个Acceptor</h5>
<figure data-type="image" tabindex="7"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419233428220.png" alt="image-20200419233428220" loading="lazy"></figure>
<p>提出假设，从假设得到的约束提交</p>
<figure data-type="image" tabindex="8"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419233552459.png" alt="image-20200419233552459" loading="lazy"></figure>
<p>上面是因为“一个提案只要被一个Acceptor接受，则该提案的value就被选定”才导致出现不一致的问题。因此，我们需要加一个规定：</p>
<blockquote>
<p>规定：一个提案被选定需要过半数以上的Acceptor接受</p>
</blockquote>
<p>上面的规定又暗示：一个Acceptor必须能够接受不止一个提案！</p>
<p>不然可能导致最终没有value被选定。</p>
<p>所以在这种情况下，我们使用一个<strong>全局的编号</strong>来标识每一个Acceptor批准的提案，当一个具有某value值的提案被半数以上Acceptor批准后，就认为该value被选定了，此时也认为该提案被选定了。</p>
<p>但是强调下，提案和value不是同一个概念，<code>提案=提案编号+value</code>。</p>
<p>根据上面的内容，我们现在虽然允许多个提案被选定，但必须保证所有被选定的提案都具有相同的value值，否则又会出现不一致。</p>
<p>于是有了下面的约束：</p>
<blockquote>
<p>P2：如果某个value为v的提案被选定了，那么每个编号更高的被选定提案的value必须也是v。</p>
</blockquote>
<p>一个提案只有被Acceptor接受才可能被选定，因此我们可以把P2约束改写成对Acceptor接受的提案的约束P2a。</p>
<blockquote>
<p>P2a：如果某个value为v的提案被选定了，那么每个编号更高的被Acceptor接受的提案的value必须也是v。</p>
</blockquote>
<p>只要满足了P2a，就能满足P2。</p>
<figure data-type="image" tabindex="9"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419234707824.png" alt="image-20200419234707824" loading="lazy"></figure>
<p>上图会制造一个矛盾。虽然过半数Acceptor认为V1被选定，但是宕机恢复的Acceptor1接受了Proposer1提出的编号更新的提案的V2。</p>
<p>需要对P2a约束进行强化！</p>
<p>P2a是对Acceptor接受的提案约束，但其实提案是Proposer提出来的，所以我们可以对Proposer提出的提案进行约束。得到P2b：</p>
<blockquote>
<p>P2b：如果某个value为v的提案被选定，那么之后任何Proposer提出的编号更高的提案的value必须也是v。</p>
</blockquote>
<p>由P2b可以推出P2a进而推出P2。</p>
<p>那么如何达到P2b的约束呢？</p>
<p>主要满足P2C即可：</p>
<figure data-type="image" tabindex="10"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200419235458892.png" alt="image-20200419235458892" loading="lazy"></figure>
<h5 id="proposer生产提案">Proposer生产提案</h5>
<figure data-type="image" tabindex="11"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001223255.png" alt="image-20200420001223255" loading="lazy"></figure>
<h5 id="acceptor接受提案">Acceptor接受提案</h5>
<figure data-type="image" tabindex="12"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001245863.png" alt="image-20200420001245863" loading="lazy"></figure>
<blockquote>
<p>P1a：一个Acceptor只要尚未响应过任何编号大于N的Prepare请求，那么他就可以接受这个编号为N的提案。</p>
</blockquote>
<h5 id="算法优化">算法优化</h5>
<figure data-type="image" tabindex="13"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420000527733.png" alt="image-20200420000527733" loading="lazy"></figure>
<blockquote>
<p>如果Acceptor收到一个编号为N的Prepare请求，在此之前他已经响应过编号大于N的Prepare请求。根据P1a，该Acceptor不可能接受编号为N的提案。因此，该Acceptor可以忽略编号为N的Prepare请求。</p>
</blockquote>
<h4 id="paxos算法描述">Paxos算法描述</h4>
<figure data-type="image" tabindex="14"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420000848207.png" alt="image-20200420000848207" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420000910502.png" alt="image-20200420000910502" loading="lazy"></figure>
<h4 id="leaner学习被选定的value">Leaner学习被选定的value</h4>
<p>上面介绍了如何来选定一个提案，下面看看如何让Leaner获取提案，大体有三种方案</p>
<figure data-type="image" tabindex="16"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001022065.png" alt="image-20200420001022065" loading="lazy"></figure>
<h4 id="如何保证paxos算法的活性">如何保证Paxos算法的活性</h4>
<p>活性：最终一定会发生的事情：最终一定要选定value</p>
<figure data-type="image" tabindex="17"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001348380.png" alt="image-20200420001348380" loading="lazy"></figure>
<p>总结：</p>
<figure data-type="image" tabindex="18"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420001658059.png" alt="image-20200420001658059" loading="lazy"></figure>
<h3 id="分布式理论一致性算法raft">分布式理论：一致性算法Raft</h3>
<h4 id="什么是raft算法">什么是Raft算法</h4>
<p><strong>Raft是一种为了管理复制日志的一致性算法</strong>。</p>
<p>Raft将一致性算法分解成几个关键模块，领导人选举、日志复制和安全性</p>
<p>通过实施一个更强的一致性来减少需要考虑的状态的数量。</p>
<p>Raft算法分为<strong>两个阶段，首先是选举过程，然后在选举出来的领导人带领下进行正常操作</strong>，比如日志复制。</p>
<h4 id="领导人选举">领导人选举</h4>
<p>Raft通过选举一个领导人，然后给予他全部的管理复制日志的责任来实现一致性。</p>
<p>在Raft中，任何时候一个服务器都可以扮演下面的角色之一：</p>
<ul>
<li>领导者：处理客户端交互，日志复制等操作，一般一次只有一个领导者</li>
<li>候选者：候选者就是选举过程中提名自己的实体，一旦选举成功，则成为领导者</li>
<li>跟随者：类似选民，完全被动的角色，这样的服务器等待被通知投票</li>
</ul>
<p>而影响他们身份变化的则是<strong>选举</strong>。</p>
<p>Raft使用心跳机制来触发选举。</p>
<p>当server启动时，初始状态都是follower。每一个server都有一个定时器，超时时间为election timeout(一般为150-300ms)，如果某server没有超时的情况下收到来自领导者或者候选者的任何消息，定时器重启；如果超时，它就开始一次选举。</p>
<p>下面用图示展示这个过程：</p>
<ol>
<li>任何一个服务器都可以成为候选者，它向其他服务器（选民）发出选举自己的请求，如图</li>
</ol>
<figure data-type="image" tabindex="19"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420122557641_2020_04_20_12_25_57.png" alt="image-20200420122557641" loading="lazy"></figure>
<ol start="2">
<li>其他服务器同意了，回复OK指令，如图所示。</li>
</ol>
<figure data-type="image" tabindex="20"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420122637006_2020_04_20_12_26_37.png" alt="image-20200420122637006" loading="lazy"></figure>
<p>此时如果有一个Follower服务器宕机，没有收到请求选举的要求，则只要达到半数以上的票数，候选人还是可以成为领导者。</p>
<ol start="3">
<li>这样，这个候选者就成为领导者，它可以向选民发出要执行具体操作的指令，比如进行日志复制。</li>
</ol>
<figure data-type="image" tabindex="21"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420122810137_2020_04_20_12_28_10.png" alt="image-20200420122810137" loading="lazy"></figure>
<p>而如果领导者宕机，会引发新的选举，所以，整个集群在选举和正常运行两个状态之间切换，具体如下图：</p>
<figure data-type="image" tabindex="22"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420122934631_2020_04_20_12_29_34.png" alt="image-20200420122934631" loading="lazy"></figure>
<p>从上图可以看出，选举和正常运行之间切换，但请注意，上图中的term3有一个地方，后面没有跟着正常阶段，为什么呢？</p>
<p>答：当一次选举失败（比如正巧每个人都透了自己），就执行一次加时赛，每个server会在一个随机的时间重新投票，这样就能保证不冲突了。所以，当term3选举失败，等了几十毫秒，执行term4选举，并成功选举出领导人。</p>
<p>接着，领导者周期性的向所有跟随者发送心跳包来维持自己的权威。</p>
<p>如果一个跟随者在一段时间内没有收到任何信息，也就是<strong>超时</strong>，那么他就会认为系统中没有可用的领导者，并且发起选举，以选出新的领导者。</p>
<p>要开始一次选举过程，跟随者要增加自己的当期任期号并转换到候选人状态。然后请求其他服务器为自己投票。那么会产生3种结果：</p>
<ol>
<li>自己成功当选</li>
<li>其他服务器成为领导者</li>
<li>僵住，没有任何一个人成为领导者</li>
</ol>
<p>注意：</p>
<ol>
<li>每一个server最多在一个任期内投出一张选票（有任期号约束），先到先得。</li>
<li>要求最多只能有一个人赢的选票。</li>
<li>一旦成功，立即成为领导人，然后广播所有服务器停止投票阻止新的领导者产生。</li>
</ol>
<p>僵住怎么办？raft通过使用随机选举超时时间方法将服务器打散投票。每个候选人在僵住的时候会随机从一个时间开始重新选举。</p>
<p>以上，就是Raft所有关于领导选举的策略。</p>
<h4 id="日志复制保证数据一致性">日志复制（保证数据一致性）</h4>
<p>Leader选出后，就开始接收客户端请求。Leader把请求作为日志条目加入到它的日志中，然后并行的向其他服务器发起AppendEntries RPC复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。</p>
<p>下图表示了当一个客户端发送一个请求给领导者，随后领导者复制给跟随者的整个过程。</p>
<figure data-type="image" tabindex="23"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420131317613_2020_04_20_13_13_17.png" alt="image-20200420131317613" loading="lazy"></figure>
<p>4个步骤：</p>
<ul>
<li>客户端的每一个请求都包含被复制状态机执行的指令</li>
<li>leader把这个指令作为一条新的日志添加到日志中，然后并行发起RPC给其他服务器，让他们复制这条信息</li>
<li>跟随者响应ACK，如果follower宕机或者运行缓慢或者丢包，leader会不断重试，直到所有的follower最终都复制了所有的日志条目。</li>
<li>通知所有Follower提交日志，同时领导人提交这条日志到自己的状态机中，并返回给客户端。</li>
</ul>
<p>可以看到，直到第四步骤，整个事务才会达成。中间任何一个步骤发生故障，都不会影响日志的一致性。</p>
<h2 id="分布式系统设计策略">分布式系统设计策略</h2>
<p>分布式系统本质是通过将低廉的硬件攒在一起以获得更好的吞吐量、性能以及可用性等。</p>
<p>在分布式环境下，有几个问题是普遍关心的，我们称之为设计策略：</p>
<ul>
<li>如何检测当前节点还活着？</li>
<li>如何保障高可用</li>
<li>容错处理</li>
<li>负载均衡</li>
</ul>
<h3 id="心跳检测">心跳检测</h3>
<p>心跳，就是以固定的频率向其他节点汇报当前节点状态的方式。收到心跳，一般可以认为一个节点和现在的网络拓扑是良好的。当然，心跳汇报时，一般也会携带一些附加的状态、元数据信息，以便管理。</p>
<p>心跳不是万能的，收到心跳可以确认节点正常，但是收不到心跳也不能认为该节点就已经宣告&quot;死亡&quot;。此时，可以通过一些方法帮助Server做决定：周期检测心跳机制、累计失效检测机制。</p>
<p>周期检测心跳机制</p>
<p>Server端每间隔t秒向Node集群发起监测请求，设定超时时间，如果超过超过时间，则判断“死亡”。</p>
<p>累计失效检测机制</p>
<p>在周期监测心跳机制基础上，统计一定周期内节点的返回情况（包括超时及正确返回），以计算节点的死亡概率。另外，对于宣告“濒临死亡”的节点可以发起有限次数的重试，以作进一步判断。</p>
<h3 id="高可用设计">高可用设计</h3>
<p>经过设计来减少系统不能提供服务的时间。</p>
<p>系统高可用性常用设计模式包括三种：主备（Master-Slave）、互备（Active-Active）和集群（Cluster）模式。</p>
<figure data-type="image" tabindex="24"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420182325069_2020_04_20_18_23_25.png" alt="image-20200420182325069" loading="lazy"></figure>
<figure data-type="image" tabindex="25"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420182552945_2020_04_20_18_25_53.png" alt="image-20200420182552945" loading="lazy"></figure>
<figure data-type="image" tabindex="26"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420182714765_2020_04_20_18_27_15.png" alt="image-20200420182714765" loading="lazy"></figure>
<h3 id="容错性">容错性</h3>
<p>容错的处理是保障分布式环境下相应系统的高可用或者健壮性，一个典型的案例就是对于缓存穿透问题的解决方案。</p>
<p>具体看个例子，如图所示：</p>
<figure data-type="image" tabindex="27"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420182850598_2020_04_20_18_28_50.png" alt="image-20200420182850598" loading="lazy"></figure>
<p>如果我们查询的某一数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，或者有人恶意攻击，如频繁发起id为-1的条件进行查询，可能DB就挂了。</p>
<p>那这种问题有什么好的解决办法吗？</p>
<p>一种方法可以缓存不存在的值，比如，key=&quot;null&quot;。</p>
<h3 id="负载均衡">负载均衡</h3>
<p>关键在于使用多台集群服务器共同分担计算任务，把网络请求及计算分配到集群可用的不同服务器节点上，从而达到高可用性及较好的用户操作体验。</p>
<figure data-type="image" tabindex="28"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic/image-20200420183322517_2020_04_20_18_33_22.png" alt="image-20200420183322517" loading="lazy"></figure>
<h2 id="分布式架构网络通信">分布式架构网络通信</h2>
<p>Java领域通信的技术，有RMI、ESB、Hession、SOAP和JMS等，它们背后到底是基于什么原理实现的呢？</p>
<h3 id="基本原理">基本原理</h3>
<p>网络通信就是将流从一台计算机传输到另一台计算机，基于传输协议和网络IO来实现。</p>
<p>传输协议：TCP、UDP</p>
<p>网络IO：bio、nio、aio</p>
<h3 id="什么是rpc">什么是RPC</h3>
<p>RPC全称为remote procedure call，即远程过程调用。</p>
<p>借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式。</p>
<p>RPC本身不是具体的技术，是整个网络远程调用过程。</p>
<h4 id="rpc架构">RPC架构</h4>
<p>核心组件</p>
<ul>
<li>客户端（Client），服务的调用方</li>
<li>客户端存根（Client Stub），存放服务端端地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。</li>
<li>服务端（Server），真正的服务提供者。</li>
<li>服务端存根（Server Stub），接收客户端发送过来的消息，将消息解包，并调用本地的方法。</li>
</ul>
<figure data-type="image" tabindex="29"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420224748087.png" alt="image-20200420224748087" loading="lazy"></figure>
<figure data-type="image" tabindex="30"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225107848.png" alt="image-20200420225107848" loading="lazy"></figure>
<figure data-type="image" tabindex="31"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225147534.png" alt="image-20200420225147534" loading="lazy"></figure>
<p>对于RPC框架而言，核心模块就是通讯和序列化。</p>
<h3 id="rmi">RMI</h3>
<p>Remote Method Invocation，是Java原生支持的远程调用，才用JRMP作为通信协议。主要用于不同虚拟机间的通信。可以理解为一个虚拟机上的对象，调用另一个虚拟机上的对象。</p>
<h4 id="核心概念">核心概念</h4>
<figure data-type="image" tabindex="32"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225438139.png" alt="###" loading="lazy"></figure>
<p>以一个案例来讲解RMI的使用</p>
<h4 id="案例步骤">案例步骤</h4>
<figure data-type="image" tabindex="33"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225539956.png" alt="image-20200420225539956" loading="lazy"></figure>
<h4 id="代码实现">代码实现</h4>
<figure data-type="image" tabindex="34"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225616739.png" alt="image-20200420225616739" loading="lazy"></figure>
<p>其中有一个引用对象作为参数</p>
<figure data-type="image" tabindex="35"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225657770.png" alt="image-20200420225657770" loading="lazy"></figure>
<figure data-type="image" tabindex="36"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225718220.png" alt="image-20200420225718220" loading="lazy"></figure>
<figure data-type="image" tabindex="37"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420225728445.png" alt="image-20200420225728445" loading="lazy"></figure>
<figure data-type="image" tabindex="38"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420231948021.png" alt="image-20200420231948021" loading="lazy"></figure>
<figure data-type="image" tabindex="39"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420231958643.png" alt="image-20200420231958643" loading="lazy"></figure>
<figure data-type="image" tabindex="40"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420232049926.png" alt="image-20200420232049926" loading="lazy"></figure>
<p>服务端</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420232156745.png" alt="image-20200420232156745" style="zoom:33%;" />
<p>客户端</p>
<img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420232210761.png" alt="image-20200420232210761" style="zoom:33%;" />
<h4 id="实现原理">实现原理</h4>
<figure data-type="image" tabindex="41"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420232255853.png" alt="image-20200420232255853" loading="lazy"></figure>
<h3 id="bio-nio-aio">BIO、NIO、AIO</h3>
<p>以内存为目标，数据进内存叫IN，出内存叫OUT</p>
<h4 id="同步和异步">同步和异步</h4>
<p>不能光从字母意思了解，要从分布式的角度思考。</p>
<p>同步异步关注的是消息通信机制。</p>
<p>同步：</p>
<figure data-type="image" tabindex="42"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420235035589.png" alt="image-20200420235035589" loading="lazy"></figure>
<p>异步：</p>
<figure data-type="image" tabindex="43"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420235115587.png" alt="image-20200420235115587" loading="lazy"></figure>
<h4 id="阻塞和非阻塞">阻塞和非阻塞</h4>
<figure data-type="image" tabindex="44"><img src="https://gitee.com/jinxin.70/oss/raw/master/uPic2/image-20200420235140376.png" alt="image-20200420235140376" loading="lazy"></figure>
<h4 id="bio">BIO</h4>
<h4 id="nio">NIO</h4>
<h4 id="aio">AIO</h4>
<h4 id="netty">Netty</h4>

							</div>
							<div class="wow bounceInDown vt-post-tags">
								
								<a href="https://xinrong2019.github.io/tag/TDLpFL9v1/" rel="tag">分布式</a>
								
							</div>
							<nav class="navigation3 post-navigation3" role="navigation">

								<div class="nav-links3">
									
									
									<div class="wow bounceInRight nav-next3"><a href="https://xinrong2019.github.io/post/zookeeper-shen-du-shi-jian/"
											rel="next"> Zookeeper深度实践</a></div>
									
								</div>
							</nav>
							<div class="wow rollIn author-info" style="visibility: visible; animation-name: rollIn;">
								<div class="author-avatar pull-left"><img
										src="https://xinrong2019.github.io//images/avatar.png"></div>
								
								<div class="author-description">
									<div class="author-title">
										<div class="author-link" rel="author">Kim</div>
									</div>
									
									
									<p class="author-bio">Time waits for no one.</p>
								</div>
							</div>
							
						</div>
					</article>
					<div id="marlin_lite_about_widget-2" class="wow bounceInUp widget marlin_lite_about_widget"
						data-wow-delay="0.1s">

						
						
						<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: '2f13af052cedc58f1f20',
    clientSecret: 'ce03139f08944b2398d0f580a3d00ff58958c242',
    repo: 'xinrong2019.github.io',
    owner: 'xinrong2019',
    admin: ['xinrong2019'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

						
						
						
						<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='https://xinrong2019.github.io//media/scripts/Valine.min.js'></script>

<div class="comment"></div>
<script>
        new Valine({
            // AV 对象来自上面引入av-min.js(老司机们不要开车➳♡゛扎心了老铁)
            av: AV, 
            el: '.comment',
            lang: 'zh-cn',
            
            
     	
      	
          
        });
    </script> 


					</div>
				</div>
				<div class="tocc col l3 hide-on-med-and-down">

    <div class="toc-widget">

        <div class="toc-title"></div>

        <div id="toc-content">


        </div>
    </div>
</div>


<script src="https://cdnjs.cloudflare.com/ajax/libs/tocbot/4.5.0/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '.entry-summary',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('.entry-summary').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });
    });

    $(function () {
        var bt;
        bt = $('.toc-widget');
        if ($(document).width() > 480) {
            $(window).scroll(function () {
                var st;
                st = $(window).scrollTop();
                if (st > 450) {
                    return bt.css('display', 'block');
                } else {
                    return bt.css('display', 'none');
                }
            })
        }
    });
</script>
			</div>
		</div>
		<footer id="colophon" class="site-footer">
	<div class="container">
		<div class="copyright">
			Created by Kim.
			<br>
			<b>Theme: </b>
			<a href="https://github.com/alterfang/gridea-theme-pan" target="_blank" title="Pan">
				<span><b>Pan</b></span>
			</a>
			<b>. Powered by </b>
			<a href="https://gridea.dev/" target="_blank" title="Gridea">
				<span><b>Gridea</b></span>
			</a>
		</div>
	</div><!-- .container -->
</footer><!-- #colophon -->
	</div>

	<script src="https://cdn.bootcss.com/fitvids/1.2.0/jquery.fitvids.min.js"></script>
<script type='text/javascript' src='https://xinrong2019.github.io//media/scripts/marlin-scripts.js'></script>
<script src="//tokinx.github.io/lately/lately.min.js"></script>
<script type='text/javascript' src="https://xinrong2019.github.io//media/scripts/mouse/love.js"></script>

<script src="https://cdn.jsdelivr.net/npm/color-thief-don@2.0.2/src/color-thief.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script>



<script>
  jQuery(document).ready(function () {
    $.lately({
      'target': '.lately-a,.lately-b,.lately-c'
    })
  });
</script>
<style type="text/css">
  /* 一键到顶部 */
  a.back_to_top {
    text-decoration: none;
    position: fixed;
    bottom: 65px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
  }

  a.back_to_top span {
    color: #888;
  }

  a.back_to_top:hover {
    cursor: pointer;
    background: #dfdfdf;
  }

  a.back_to_top:hover span {
    color: #555;
  }

  @media print,
  screen and (max-width: 580px) {
    .back_to_top {
      display: none !important;
    }
  }

  /* 一键到底部 */

  a.down_to_bottom {
    text-decoration: none;
    position: fixed;
    bottom: 15px;
    right: 30px;
    background: #f0f0f0;
    height: 40px;
    width: 40px;
    border-radius: 50%;
    line-height: 36px;
    font-size: 18px;
    text-align: center;
    transition-duration: .5s;
    transition-propety: background-color;
    display: none;
  }

  a.down_to_bottom span {
    color: #888;
  }

  a.down_to_bottom:hover {
    cursor: pointer;
    background: #dfdfdf;
  }

  a.down_to_bottom:hover span {
    color: #555;
  }

  @media print,
  screen and (max-width: 580px) {
    .down_to_bottom {
      display: none !important;
    }
  }
</style>


<a id="back_to_top" href="#" class="back_to_top"><span><i class="iconfont icon-xiangshang"></i></span>
</a>

<a id="down_to_bottom" href="#" class="down_to_bottom"><span><i class="iconfont icon-xiangxia"></i></span>
</a>

<script src="//instant.page/3.0.0" type="module" defer
  integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>

<script>
  function getScrollTop() {
    var scrollTop = 0,
      bodyScrollTop = 0,
      documentScrollTop = 0;
    if (document.body) {
      bodyScrollTop = document.body.scrollTop;
    }
    if (document.documentElement) {
      documentScrollTop = document.documentElement.scrollTop;
    }
    scrollTop = (bodyScrollTop - documentScrollTop > 0) ? bodyScrollTop : documentScrollTop;
    return scrollTop;
  };

  function getScrollHeight() {
    var scrollHeight = 0,
      bodyScrollHeight = 0,
      documentScrollHeight = 0;
    if (document.body) {
      bSH = document.body.scrollHeight;
    }
    if (document.documentElement) {
      dSH = document.documentElement.scrollHeight;
    }
    scrollHeight = (bSH - dSH > 0) ? bSH : dSH;
    return scrollHeight;
  };

  function getWindowHeight() {
    var windowHeight = 0;
    if (document.compatMode == "CSS1Compat") {
      windowHeight = document.documentElement.clientHeight;
    } else {
      windowHeight = document.body.clientHeight;
    }
    return windowHeight;
  };

  $(document).ready((function (_this) {
    return function () {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function () {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block');
          } else {
            return bt.css('display', 'none');
          }
        });
        return bt.click(function () {
          $('body,html').animate({
            scrollTop: 0
          }, 800);
          return false;
        });
      }
    };
  })(this));

  $(document).ready((function (_this) {
    return function () {
      var bt;
      bt = $('#down_to_bottom');
      if ($(document).width() > 480) {
        $(window).scroll(function () {
          var st;
          st = $(window).scrollTop();
          if (getScrollTop() + getWindowHeight() == getScrollHeight()) {
            return bt.css('display', 'none');
          } else {
            return bt.css('display', 'block');
          }
        });
        return bt.click(function () {
          $('body,html').animate({
            scrollTop: $('body,html')[0].scrollHeight
          }, 800);
          return false;
        });
      }
    };
  })(this));
</script>
	<script data-no-instant>
		(function ($) {
			$.extend({
				adamsOverload: function () {
					$('.navigation:eq(0)').remove();
					$("").attr("rel", "external");
					$("a[rel='external'],a[rel='external nofollow']").attr("target", "_blank");
					$("a.vi").attr("rel", "");
					$.viewImage({
						'target': 'img',
						'exclude': '.vsmile-icons img,.gallery img',
						'delay': 300
					});
					$.lately({
						'target': '.commentmetadata a,.infos time,.post-list time'
					});
					prettyPrint();

					$('ul.links li a').each(function () {
						if ($(this).parent().find('.bg').length == 0) {
							$(this).parent().append(
								'<!---<div class="bg" style="background-image:url(https://c3.glgoo.top/s2/favicons?domain=' +
								$(this).attr("href") + ')"></div>--->')
						}
					});
				}
			});
		})(jQuery);
		jQuery.adamsOverload();
	</script>

</body>

</html>